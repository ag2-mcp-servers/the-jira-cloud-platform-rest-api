# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T16:06:34+00:00

from __future__ import annotations

from datetime import date as date_aliased
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union
from uuid import UUID

from pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel, constr


class ActorInputBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    group: Optional[List[str]] = Field(
        None,
        description='The name of the group to add as a default actor. This parameter cannot be used with the `groupId` parameter. As a group\'s name can change,use of `groupId` is recommended. This parameter accepts a comma-separated list. For example, `"group":["project-admin", "jira-developers"]`.',
    )
    groupId: Optional[List[str]] = Field(
        None,
        description='The ID of the group to add as a default actor. This parameter cannot be used with the `group` parameter This parameter accepts a comma-separated list. For example, `"groupId":["77f6ab39-e755-4570-a6ae-2d7a8df0bcb8", "0c011f85-69ed-49c4-a801-3b18d0f771bc"]`.',
    )
    user: Optional[List[str]] = Field(
        None,
        description='The account IDs of the users to add as default actors. This parameter accepts a comma-separated list. For example, `"user":["5b10a2844c20165700ede21g", "5b109f2e9729b51b54dc274d"]`.',
    )


class ActorsMap(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    group: Optional[List[str]] = Field(
        None,
        description="The name of the group to add. This parameter cannot be used with the `groupId` parameter. As a group's name can change, use of `groupId` is recommended.",
    )
    groupId: Optional[List[str]] = Field(
        None,
        description='The ID of the group to add. This parameter cannot be used with the `group` parameter.',
    )
    user: Optional[List[str]] = Field(
        None, description='The user account ID of the user to add.'
    )


class AddFieldBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fieldId: str = Field(..., description='The ID of the field to add.')


class AddGroupBean(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: str = Field(..., description='The name of the group.')


class Visibility(Enum):
    PUBLIC = 'PUBLIC'
    PRIVATE = 'PRIVATE'


class AnnouncementBannerConfiguration(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    hashId: Optional[str] = Field(
        None,
        description='Hash of the banner data. The client detects updates by comparing hash IDs.',
    )
    isDismissible: Optional[bool] = Field(
        None,
        description='Flag indicating if the announcement banner can be dismissed by the user.',
    )
    isEnabled: Optional[bool] = Field(
        None,
        description='Flag indicating if the announcement banner is enabled or not.',
    )
    message: Optional[str] = Field(
        None, description='The text on the announcement banner.'
    )
    visibility: Optional[Visibility] = Field(
        None, description='Visibility of the announcement banner.'
    )


class AnnouncementBannerConfigurationUpdate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isDismissible: Optional[bool] = Field(
        None,
        description='Flag indicating if the announcement banner can be dismissed by the user.',
    )
    isEnabled: Optional[bool] = Field(
        None,
        description='Flag indicating if the announcement banner is enabled or not.',
    )
    message: Optional[str] = Field(
        None, description='The text on the announcement banner.'
    )
    visibility: Optional[str] = Field(
        None,
        description='Visibility of the announcement banner. Can be public or private.',
    )


class Application(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    name: Optional[str] = Field(
        None,
        description='The name of the application. Used in conjunction with the (remote) object icon title to display a tooltip for the link\'s icon. The tooltip takes the format "\\[application name\\] icon title". Blank items are excluded from the tooltip title. If both items are blank, the icon tooltop displays as "Web Link". Grouping and sorting of links may place links without an application name last.',
    )
    type: Optional[str] = Field(
        None,
        description='The name-spaced type of the application, used by registered rendering apps.',
    )


class ApplicationProperty(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allowedValues: Optional[List[str]] = Field(
        None, description='The allowed values, if applicable.'
    )
    defaultValue: Optional[str] = Field(
        None, description='The default value of the application property.'
    )
    desc: Optional[str] = Field(
        None, description='The description of the application property.'
    )
    example: Optional[str] = None
    id: Optional[str] = Field(
        None,
        description='The ID of the application property. The ID and key are the same.',
    )
    key: Optional[str] = Field(
        None,
        description='The key of the application property. The ID and key are the same.',
    )
    name: Optional[str] = Field(
        None, description='The name of the application property.'
    )
    type: Optional[str] = Field(
        None, description='The data type of the application property.'
    )
    value: Optional[str] = Field(None, description='The new value.')


class AssociatedItemBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description='The ID of the associated record.')
    name: Optional[str] = Field(None, description='The name of the associated record.')
    parentId: Optional[str] = Field(
        None, description='The ID of the associated parent record.'
    )
    parentName: Optional[str] = Field(
        None, description='The name of the associated parent record.'
    )
    typeName: Optional[str] = Field(
        None, description='The type of the associated record.'
    )


class AttachmentArchiveEntry(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    abbreviatedName: Optional[str] = None
    entryIndex: Optional[int_aliased] = None
    mediaType: Optional[str] = None
    name: Optional[str] = None
    size: Optional[int_aliased] = None


class AttachmentArchiveImpl(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    entries: Optional[List[AttachmentArchiveEntry]] = Field(
        None, description='The list of the items included in the archive.'
    )
    totalEntryCount: Optional[int_aliased] = Field(
        None, description='The number of items in the archive.'
    )


class AttachmentArchiveItemReadable(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    index: Optional[int_aliased] = Field(
        None, description='The position of the item within the archive.'
    )
    label: Optional[str] = Field(None, description='The label for the archive item.')
    mediaType: Optional[str] = Field(
        None, description='The MIME type of the archive item.'
    )
    path: Optional[str] = Field(None, description='The path of the archive item.')
    size: Optional[str] = Field(None, description='The size of the archive item.')


class AttachmentArchiveMetadataReadable(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    entries: Optional[List[AttachmentArchiveItemReadable]] = Field(
        None, description='The list of the items included in the archive.'
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the attachment.')
    mediaType: Optional[str] = Field(
        None, description='The MIME type of the attachment.'
    )
    name: Optional[str] = Field(None, description='The name of the archive file.')
    totalEntryCount: Optional[int_aliased] = Field(
        None, description='The number of items included in the archive.'
    )


class AttachmentSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = Field(
        None, description='Whether the ability to add attachments is enabled.'
    )
    uploadLimit: Optional[int_aliased] = Field(
        None, description='The maximum size of attachments permitted, in bytes.'
    )


class AutoCompleteSuggestion(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    displayName: Optional[str] = Field(
        None,
        description='The display name of a suggested item. If `fieldValue` or `predicateValue` are provided, the matching text is highlighted with the HTML bold tag.',
    )
    value: Optional[str] = Field(None, description='The value of a suggested item.')


class AutoCompleteSuggestions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    results: Optional[List[AutoCompleteSuggestion]] = Field(
        None, description='The list of suggested item.'
    )


class AvailableDashboardGadget(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    moduleKey: Optional[str] = Field(
        None, description='The module key of the gadget type.'
    )
    title: str = Field(..., description='The title of the gadget.')
    uri: Optional[str] = Field(None, description='The URI of the gadget type.')


class AvailableDashboardGadgetsResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    gadgets: List[AvailableDashboardGadget] = Field(
        ..., description='The list of available gadgets.'
    )


class Avatar(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    fileName: Optional[str] = Field(
        None,
        description='The file name of the avatar icon. Returned for system avatars.',
    )
    id: str = Field(..., description='The ID of the avatar.')
    isDeletable: Optional[bool] = Field(
        None, description='Whether the avatar can be deleted.'
    )
    isSelected: Optional[bool] = Field(
        None,
        description="Whether the avatar is used in Jira. For example, shown as a project's avatar.",
    )
    isSystemAvatar: Optional[bool] = Field(
        None, description='Whether the avatar is a system avatar.'
    )
    owner: Optional[str] = Field(
        None,
        description='The owner of the avatar. For a system avatar the owner is null (and nothing is returned). For non-system avatars this is the appropriate identifier, such as the ID for a project or the account ID for a user.',
    )
    urls: Optional[Dict[str, AnyUrl]] = Field(
        None, description='The list of avatar icon URLs.'
    )


class AvatarUrlsBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field_16x16: Optional[AnyUrl] = Field(
        None, alias='16x16', description="The URL of the item's 16x16 pixel avatar."
    )
    field_24x24: Optional[AnyUrl] = Field(
        None, alias='24x24', description="The URL of the item's 24x24 pixel avatar."
    )
    field_32x32: Optional[AnyUrl] = Field(
        None, alias='32x32', description="The URL of the item's 32x32 pixel avatar."
    )
    field_48x48: Optional[AnyUrl] = Field(
        None, alias='48x48', description="The URL of the item's 48x48 pixel avatar."
    )


class Avatars(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    custom: Optional[List[Avatar]] = Field(None, description='Custom avatars list.')
    system: Optional[List[Avatar]] = Field(None, description='System avatars list.')


class BulkIssueIsWatching(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issuesIsWatching: Optional[Dict[str, bool]] = Field(
        None, description='The map of issue ID to boolean watch status.'
    )


class BulkProjectPermissionGrants(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issues: List[int_aliased] = Field(
        ..., description='IDs of the issues the user has the permission for.'
    )
    permission: str = Field(..., description='A project permission,')
    projects: List[int_aliased] = Field(
        ..., description='IDs of the projects the user has the permission for.'
    )


class BulkProjectPermissions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issues: Optional[List[int_aliased]] = Field(None, description='List of issue IDs.')
    permissions: List[str] = Field(..., description='List of project permissions.')
    projects: Optional[List[int_aliased]] = Field(
        None, description='List of project IDs.'
    )


class ChangeDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field: Optional[str] = Field(None, description='The name of the field changed.')
    fieldId: Optional[str] = Field(None, description='The ID of the field changed.')
    fieldtype: Optional[str] = Field(None, description='The type of the field changed.')
    from_: Optional[str] = Field(
        None, alias='from', description='The details of the original value.'
    )
    fromString: Optional[str] = Field(
        None, description='The details of the original value as a string.'
    )
    to: Optional[str] = Field(None, description='The details of the new value.')


class ChangeFilterOwner(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountId: str = Field(..., description='The account ID of the new owner.')


class ChangedValueBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    changedFrom: Optional[str] = Field(
        None, description='The value of the field before the change.'
    )
    changedTo: Optional[str] = Field(
        None, description='The value of the field after the change.'
    )
    fieldName: Optional[str] = Field(None, description='The name of the field changed.')


class ColumnItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    label: Optional[str] = Field(None, description='The issue navigator column label.')
    value: Optional[str] = Field(None, description='The issue navigator column value.')


class ComponentIssuesCount(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueCount: Optional[int_aliased] = Field(
        None, description='The count of issues assigned to a component.'
    )
    self: Optional[AnyUrl] = Field(
        None, description='The URL for this count of issues for a component.'
    )


class AssigneeType(Enum):
    PROJECT_DEFAULT = 'PROJECT_DEFAULT'
    COMPONENT_LEAD = 'COMPONENT_LEAD'
    PROJECT_LEAD = 'PROJECT_LEAD'
    UNASSIGNED = 'UNASSIGNED'


class RealAssigneeType(Enum):
    PROJECT_DEFAULT = 'PROJECT_DEFAULT'
    COMPONENT_LEAD = 'COMPONENT_LEAD'
    PROJECT_LEAD = 'PROJECT_LEAD'
    UNASSIGNED = 'UNASSIGNED'


class Operator(Enum):
    and_ = 'and'
    or_ = 'or'
    not_ = 'not'


class FieldType(Enum):
    StringIssueField = 'StringIssueField'
    NumberIssueField = 'NumberIssueField'
    RichTextIssueField = 'RichTextIssueField'
    SingleSelectIssueField = 'SingleSelectIssueField'
    MultiSelectIssueField = 'MultiSelectIssueField'
    TextIssueField = 'TextIssueField'


class ConnectCustomFieldValue(BaseModel):
    field_type: FieldType = Field(
        ..., alias='_type', description='The type of custom field.'
    )
    fieldID: int_aliased = Field(..., description='The custom field ID.')
    issueID: int_aliased = Field(..., description='The issue ID.')
    number: Optional[float] = Field(
        None,
        description='The value of number type custom field when `_type` is `NumberIssueField`.',
    )
    optionID: Optional[str] = Field(
        None,
        description='The value of single select and multiselect custom field type when `_type` is `SingleSelectIssueField` or `MultiSelectIssueField`.',
    )
    richText: Optional[str] = Field(
        None,
        description='The value of richText type custom field when `_type` is `RichTextIssueField`.',
    )
    string: Optional[str] = Field(
        None,
        description='The value of string type custom field when `_type` is `StringIssueField`.',
    )
    text: Optional[str] = Field(
        None,
        description='The value of of text custom field type when `_type` is `TextIssueField`.',
    )


class ConnectCustomFieldValues(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    updateValueList: Optional[List[ConnectCustomFieldValue]] = Field(
        None, description='The list of custom field update details.'
    )


class ConnectModule(BaseModel):
    pass


class ConnectModules(BaseModel):
    modules: List[ConnectModule] = Field(
        ...,
        description='A list of app modules in the same format as the `modules` property in the\n[app descriptor](https://developer.atlassian.com/cloud/jira/platform/app-descriptor/).',
    )


class ContainerForWebhookIDs(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    webhookIds: List[int_aliased] = Field(..., description='A list of webhook IDs.')


class ContextForProjectAndIssueType(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    contextId: str = Field(..., description='The ID of the custom field context.')
    issueTypeId: str = Field(..., description='The ID of the issue type.')
    projectId: str = Field(..., description='The ID of the project.')


class ContextualConfiguration(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    configuration: Optional[Any] = Field(None, description='The field configuration.')
    fieldContextId: str = Field(
        ...,
        description='The ID of the field context the configuration is associated with.',
    )
    id: str = Field(..., description='The ID of the configuration.')
    schema_: Optional[Any] = Field(
        None, alias='schema', description='The field value schema.'
    )


class CreateCustomFieldContext(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the context.'
    )
    id: Optional[str] = Field(None, description='The ID of the context.')
    issueTypeIds: Optional[List[str]] = Field(
        None,
        description='The list of issue types IDs for the context. If the list is empty, the context refers to all issue types.',
    )
    name: str = Field(..., description='The name of the context.')
    projectIds: Optional[List[str]] = Field(
        None,
        description='The list of project IDs associated with the context. If the list is empty, the context is global.',
    )


class IconUrl(Enum):
    field_images_icons_priorities_blocker_png = '/images/icons/priorities/blocker.png'
    field_images_icons_priorities_critical_png = '/images/icons/priorities/critical.png'
    field_images_icons_priorities_high_png = '/images/icons/priorities/high.png'
    field_images_icons_priorities_highest_png = '/images/icons/priorities/highest.png'
    field_images_icons_priorities_low_png = '/images/icons/priorities/low.png'
    field_images_icons_priorities_lowest_png = '/images/icons/priorities/lowest.png'
    field_images_icons_priorities_major_png = '/images/icons/priorities/major.png'
    field_images_icons_priorities_medium_png = '/images/icons/priorities/medium.png'
    field_images_icons_priorities_minor_png = '/images/icons/priorities/minor.png'
    field_images_icons_priorities_trivial_png = '/images/icons/priorities/trivial.png'


class CreatePriorityDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    description: Optional[constr(max_length=255)] = Field(
        None, description='The description of the priority.'
    )
    iconUrl: Optional[IconUrl] = Field(
        None,
        description='The URL of an icon for the priority. Accepted protocols are HTTP and HTTPS. Built in icons can also be used.',
    )
    name: constr(max_length=60) = Field(
        ..., description='The name of the priority. Must be unique.'
    )
    statusColor: str = Field(
        ...,
        description='The status color of the priority in 3-digit or 6-digit hexadecimal format.',
    )


class AssigneeType1(Enum):
    PROJECT_LEAD = 'PROJECT_LEAD'
    UNASSIGNED = 'UNASSIGNED'


class ProjectTemplateKey(Enum):
    com_pyxis_greenhopper_jira_gh_simplified_agility_kanban = (
        'com.pyxis.greenhopper.jira:gh-simplified-agility-kanban'
    )
    com_pyxis_greenhopper_jira_gh_simplified_agility_scrum = (
        'com.pyxis.greenhopper.jira:gh-simplified-agility-scrum'
    )
    com_pyxis_greenhopper_jira_gh_simplified_basic = (
        'com.pyxis.greenhopper.jira:gh-simplified-basic'
    )
    com_pyxis_greenhopper_jira_gh_simplified_kanban_classic = (
        'com.pyxis.greenhopper.jira:gh-simplified-kanban-classic'
    )
    com_pyxis_greenhopper_jira_gh_simplified_scrum_classic = (
        'com.pyxis.greenhopper.jira:gh-simplified-scrum-classic'
    )
    com_atlassian_servicedesk_simplified_it_service_management = (
        'com.atlassian.servicedesk:simplified-it-service-management'
    )
    com_atlassian_servicedesk_simplified_general_service_desk = (
        'com.atlassian.servicedesk:simplified-general-service-desk'
    )
    com_atlassian_servicedesk_simplified_general_service_desk_it = (
        'com.atlassian.servicedesk:simplified-general-service-desk-it'
    )
    com_atlassian_servicedesk_simplified_general_service_desk_business = (
        'com.atlassian.servicedesk:simplified-general-service-desk-business'
    )
    com_atlassian_servicedesk_simplified_internal_service_desk = (
        'com.atlassian.servicedesk:simplified-internal-service-desk'
    )
    com_atlassian_servicedesk_simplified_external_service_desk = (
        'com.atlassian.servicedesk:simplified-external-service-desk'
    )
    com_atlassian_servicedesk_simplified_hr_service_desk = (
        'com.atlassian.servicedesk:simplified-hr-service-desk'
    )
    com_atlassian_servicedesk_simplified_facilities_service_desk = (
        'com.atlassian.servicedesk:simplified-facilities-service-desk'
    )
    com_atlassian_servicedesk_simplified_legal_service_desk = (
        'com.atlassian.servicedesk:simplified-legal-service-desk'
    )
    com_atlassian_servicedesk_simplified_marketing_service_desk = (
        'com.atlassian.servicedesk:simplified-marketing-service-desk'
    )
    com_atlassian_servicedesk_simplified_finance_service_desk = (
        'com.atlassian.servicedesk:simplified-finance-service-desk'
    )
    com_atlassian_servicedesk_simplified_analytics_service_desk = (
        'com.atlassian.servicedesk:simplified-analytics-service-desk'
    )
    com_atlassian_servicedesk_simplified_halp_service_desk = (
        'com.atlassian.servicedesk:simplified-halp-service-desk'
    )
    com_atlassian_servicedesk_simplified_custom_project_service_desk = (
        'com.atlassian.servicedesk:simplified-custom-project-service-desk'
    )
    com_atlassian_jira_core_project_templates_jira_core_simplified_content_management = 'com.atlassian.jira-core-project-templates:jira-core-simplified-content-management'
    com_atlassian_jira_core_project_templates_jira_core_simplified_document_approval = 'com.atlassian.jira-core-project-templates:jira-core-simplified-document-approval'
    com_atlassian_jira_core_project_templates_jira_core_simplified_lead_tracking = (
        'com.atlassian.jira-core-project-templates:jira-core-simplified-lead-tracking'
    )
    com_atlassian_jira_core_project_templates_jira_core_simplified_process_control = (
        'com.atlassian.jira-core-project-templates:jira-core-simplified-process-control'
    )
    com_atlassian_jira_core_project_templates_jira_core_simplified_procurement = (
        'com.atlassian.jira-core-project-templates:jira-core-simplified-procurement'
    )
    com_atlassian_jira_core_project_templates_jira_core_simplified_project_management = 'com.atlassian.jira-core-project-templates:jira-core-simplified-project-management'
    com_atlassian_jira_core_project_templates_jira_core_simplified_recruitment = (
        'com.atlassian.jira-core-project-templates:jira-core-simplified-recruitment'
    )
    com_atlassian_jira_core_project_templates_jira_core_simplified_task_ = (
        'com.atlassian.jira-core-project-templates:jira-core-simplified-task-'
    )


class ProjectTypeKey(Enum):
    software = 'software'
    service_desk = 'service_desk'
    business = 'business'


class CreateProjectDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    assigneeType: Optional[AssigneeType1] = Field(
        None, description='The default assignee when creating issues for this project.'
    )
    avatarId: Optional[int_aliased] = Field(
        None, description="An integer value for the project's avatar."
    )
    categoryId: Optional[int_aliased] = Field(
        None,
        description="The ID of the project's category. A complete list of category IDs is found using the [Get all project categories](#api-rest-api-3-projectCategory-get) operation.",
    )
    description: Optional[str] = Field(
        None, description='A brief description of the project.'
    )
    fieldConfigurationScheme: Optional[int_aliased] = Field(
        None,
        description='The ID of the field configuration scheme for the project. Use the [Get all field configuration schemes](#api-rest-api-3-fieldconfigurationscheme-get) operation to get a list of field configuration scheme IDs. If you specify the field configuration scheme you cannot specify the project template key.',
    )
    issueSecurityScheme: Optional[int_aliased] = Field(
        None,
        description='The ID of the issue security scheme for the project, which enables you to control who can and cannot view issues. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) resource to get all issue security scheme IDs.',
    )
    issueTypeScheme: Optional[int_aliased] = Field(
        None,
        description='The ID of the issue type scheme for the project. Use the [Get all issue type schemes](#api-rest-api-3-issuetypescheme-get) operation to get a list of issue type scheme IDs. If you specify the issue type scheme you cannot specify the project template key.',
    )
    issueTypeScreenScheme: Optional[int_aliased] = Field(
        None,
        description='The ID of the issue type screen scheme for the project. Use the [Get all issue type screen schemes](#api-rest-api-3-issuetypescreenscheme-get) operation to get a list of issue type screen scheme IDs. If you specify the issue type screen scheme you cannot specify the project template key.',
    )
    key: str = Field(
        ...,
        description='Project keys must be unique and start with an uppercase letter followed by one or more uppercase alphanumeric characters. The maximum length is 10 characters.',
    )
    lead: Optional[str] = Field(
        None,
        description='This parameter is deprecated because of privacy changes. Use `leadAccountId` instead. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. The user name of the project lead. Either `lead` or `leadAccountId` must be set when creating a project. Cannot be provided with `leadAccountId`.',
    )
    leadAccountId: Optional[constr(max_length=128)] = Field(
        None,
        description='The account ID of the project lead. Either `lead` or `leadAccountId` must be set when creating a project. Cannot be provided with `lead`.',
    )
    name: str = Field(..., description='The name of the project.')
    notificationScheme: Optional[int_aliased] = Field(
        None,
        description='The ID of the notification scheme for the project. Use the [Get notification schemes](#api-rest-api-3-notificationscheme-get) resource to get a list of notification scheme IDs.',
    )
    permissionScheme: Optional[int_aliased] = Field(
        None,
        description='The ID of the permission scheme for the project. Use the [Get all permission schemes](#api-rest-api-3-permissionscheme-get) resource to see a list of all permission scheme IDs.',
    )
    projectTemplateKey: Optional[ProjectTemplateKey] = Field(
        None,
        description='A predefined configuration for a project. The type of the `projectTemplateKey` must match with the type of the `projectTypeKey`.',
    )
    projectTypeKey: Optional[ProjectTypeKey] = Field(
        None,
        description="The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes), which defines the application-specific feature set. If you don't specify the project template you have to specify the project type.",
    )
    url: Optional[str] = Field(
        None,
        description='A link to information about this project, such as project documentation',
    )
    workflowScheme: Optional[int_aliased] = Field(
        None,
        description='The ID of the workflow scheme for the project. Use the [Get all workflow schemes](#api-rest-api-3-workflowscheme-get) operation to get a list of workflow scheme IDs. If you specify the workflow scheme you cannot specify the project template key.',
    )


class CreateResolutionDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    description: Optional[constr(max_length=255)] = Field(
        None, description='The description of the resolution.'
    )
    name: constr(max_length=60) = Field(
        ...,
        description='The name of the resolution. Must be unique (case-insensitive).',
    )


class CreateUpdateRoleRequestBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='A description of the project role. Required when fully updating a project role. Optional when creating or partially updating a project role.',
    )
    name: Optional[str] = Field(
        None,
        description='The name of the project role. Must be unique. Cannot begin or end with whitespace. The maximum length is 255 characters. Required when creating a project role. Optional when partially updating a project role.',
    )


class Operator1(Enum):
    AND = 'AND'
    OR = 'OR'


class CreateWorkflowCondition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[CreateWorkflowCondition]] = Field(
        None, description='The list of workflow conditions.'
    )
    configuration: Optional[Dict[str, Any]] = Field(
        None, description='EXPERIMENTAL. The configuration of the transition rule.'
    )
    operator: Optional[Operator1] = Field(
        None, description='The compound condition operator.'
    )
    type: Optional[str] = Field(None, description='The type of the transition rule.')


class CreateWorkflowStatusDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(..., description='The ID of the status.')
    properties: Optional[Dict[str, str]] = Field(
        None, description='The properties of the status.'
    )


class Type(Enum):
    global_ = 'global'
    initial = 'initial'
    directed = 'directed'


class CreateWorkflowTransitionRule(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    configuration: Optional[Dict[str, Any]] = Field(
        None, description='EXPERIMENTAL. The configuration of the transition rule.'
    )
    type: str = Field(..., description='The type of the transition rule.')


class CreateWorkflowTransitionRulesDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[CreateWorkflowCondition] = Field(
        None, description='The workflow conditions.'
    )
    postFunctions: Optional[List[CreateWorkflowTransitionRule]] = Field(
        None,
        description='The workflow post functions.\n\n**Note:** The default post functions are always added to the *initial* transition, as in:\n\n    "postFunctions": [\n        {\n            "type": "IssueCreateFunction"\n        },\n        {\n            "type": "IssueReindexFunction"\n        },\n        {\n            "type": "FireIssueEventFunction",\n            "configuration": {\n                "event": {\n                    "id": "1",\n                    "name": "issue_created"\n                }\n            }\n        }\n    ]\n\n**Note:** The default post functions are always added to the *global* and *directed* transitions, as in:\n\n    "postFunctions": [\n        {\n            "type": "UpdateIssueStatusFunction"\n        },\n        {\n            "type": "CreateCommentFunction"\n        },\n        {\n            "type": "GenerateChangeHistoryFunction"\n        },\n        {\n            "type": "IssueReindexFunction"\n        },\n        {\n            "type": "FireIssueEventFunction",\n            "configuration": {\n                "event": {\n                    "id": "13",\n                    "name": "issue_generic"\n                }\n            }\n        }\n    ]',
    )
    validators: Optional[List[CreateWorkflowTransitionRule]] = Field(
        None,
        description='The workflow validators.\n\n**Note:** The default permission validator is always added to the *initial* transition, as in:\n\n    "validators": [\n        {\n            "type": "PermissionValidator",\n            "configuration": {\n                "permissionKey": "CREATE_ISSUES"\n            }\n        }\n    ]',
    )


class CreateWorkflowTransitionScreenDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(..., description='The ID of the screen.')


class CustomFieldConfigurations(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    configurations: List[ContextualConfiguration] = Field(
        ...,
        description='The list of custom field configuration details.',
        max_length=1000,
        min_length=1,
    )


class CustomFieldContext(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: str = Field(..., description='The description of the context.')
    id: str = Field(..., description='The ID of the context.')
    isAnyIssueType: bool = Field(
        ..., description='Whether the context apply to all issue types.'
    )
    isGlobalContext: bool = Field(..., description='Whether the context is global.')
    name: str = Field(..., description='The name of the context.')


class CustomFieldContextDefaultValueCascadingOption(BaseModel):
    cascadingOptionId: Optional[str] = Field(
        None, description='The ID of the default cascading option.'
    )
    contextId: str = Field(..., description='The ID of the context.')
    optionId: str = Field(..., description='The ID of the default option.')
    type: Literal['option.cascading']


class CustomFieldContextDefaultValueDate(BaseModel):
    date: Optional[str] = Field(
        None,
        description='The default date in ISO format. Ignored if `useCurrent` is true.',
    )
    type: Literal['datepicker']
    useCurrent: Optional[bool] = Field(
        False, description='Whether to use the current date.'
    )


class CustomFieldContextDefaultValueDateTime(BaseModel):
    dateTime: Optional[str] = Field(
        None,
        description='The default date-time in ISO format. Ignored if `useCurrent` is true.',
    )
    type: Literal['datetimepicker']
    useCurrent: Optional[bool] = Field(
        False, description='Whether to use the current date.'
    )


class CustomFieldContextDefaultValueFloat(BaseModel):
    number: float = Field(..., description='The default floating-point number.')
    type: Literal['float']


class CustomFieldContextDefaultValueForgeDateTimeField(BaseModel):
    contextId: str = Field(..., description='The ID of the context.')
    dateTime: Optional[str] = Field(
        None,
        description='The default date-time in ISO format. Ignored if `useCurrent` is true.',
    )
    type: Literal['forge.datetime']
    useCurrent: Optional[bool] = Field(
        False, description='Whether to use the current date.'
    )


class CustomFieldContextDefaultValueForgeGroupField(BaseModel):
    contextId: str = Field(..., description='The ID of the context.')
    groupId: str = Field(..., description='The ID of the the default group.')
    type: Literal['forge.group']


class CustomFieldContextDefaultValueForgeMultiGroupField(BaseModel):
    contextId: str = Field(..., description='The ID of the context.')
    groupIds: List[str] = Field(..., description='The IDs of the default groups.')
    type: Literal['forge.group.list']


class CustomFieldContextDefaultValueForgeMultiStringField(BaseModel):
    type: Literal['forge.string.list']
    values: Optional[List[str]] = Field(
        None,
        description='List of string values. The maximum length for a value is 254 characters.',
    )


class CustomFieldContextDefaultValueForgeMultiUserField(BaseModel):
    accountIds: List[str] = Field(..., description='The IDs of the default users.')
    contextId: str = Field(..., description='The ID of the context.')
    type: Literal['forge.user.list']


class CustomFieldContextDefaultValueForgeNumberField(BaseModel):
    contextId: str = Field(..., description='The ID of the context.')
    number: float = Field(..., description='The default floating-point number.')
    type: Literal['forge.number']


class CustomFieldContextDefaultValueForgeObjectField(BaseModel):
    object: Optional[Dict[str, Any]] = Field(
        None, description='The default JSON object.'
    )
    type: Literal['forge.object']


class CustomFieldContextDefaultValueForgeStringField(BaseModel):
    contextId: str = Field(..., description='The ID of the context.')
    text: Optional[str] = Field(
        None, description='The default text. The maximum length is 254 characters.'
    )
    type: Literal['forge.string']


class CustomFieldContextDefaultValueLabels(BaseModel):
    labels: List[str] = Field(..., description='The default labels value.')
    type: Literal['labels']


class CustomFieldContextDefaultValueMultiUserPicker(BaseModel):
    accountIds: List[str] = Field(..., description='The IDs of the default users.')
    contextId: str = Field(..., description='The ID of the context.')
    type: Literal['multi.user.select']


class CustomFieldContextDefaultValueMultipleGroupPicker(BaseModel):
    contextId: str = Field(..., description='The ID of the context.')
    groupIds: List[str] = Field(..., description='The IDs of the default groups.')
    type: Literal['grouppicker.multiple']


class CustomFieldContextDefaultValueMultipleOption(BaseModel):
    contextId: str = Field(..., description='The ID of the context.')
    optionIds: List[str] = Field(
        ..., description='The list of IDs of the default options.'
    )
    type: Literal['option.multiple']


class CustomFieldContextDefaultValueMultipleVersionPicker(BaseModel):
    type: Literal['version.multiple']
    versionIds: List[str] = Field(..., description='The IDs of the default versions.')
    versionOrder: Optional[str] = Field(
        None,
        description='The order the pickable versions are displayed in. If not provided, the released-first order is used. Available version orders are `"releasedFirst"` and `"unreleasedFirst"`.',
    )


class CustomFieldContextDefaultValueProject(BaseModel):
    contextId: str = Field(..., description='The ID of the context.')
    projectId: str = Field(..., description='The ID of the default project.')
    type: Literal['project']


class CustomFieldContextDefaultValueReadOnly(BaseModel):
    text: Optional[str] = Field(
        None, description='The default text. The maximum length is 255 characters.'
    )
    type: Literal['readonly']


class CustomFieldContextDefaultValueSingleGroupPicker(BaseModel):
    contextId: str = Field(..., description='The ID of the context.')
    groupId: str = Field(..., description='The ID of the the default group.')
    type: Literal['grouppicker.single']


class CustomFieldContextDefaultValueSingleOption(BaseModel):
    contextId: str = Field(..., description='The ID of the context.')
    optionId: str = Field(..., description='The ID of the default option.')
    type: Literal['option.single']


class CustomFieldContextDefaultValueSingleVersionPicker(BaseModel):
    type: Literal['version.single']
    versionId: str = Field(..., description='The ID of the default version.')
    versionOrder: Optional[str] = Field(
        None,
        description='The order the pickable versions are displayed in. If not provided, the released-first order is used. Available version orders are `"releasedFirst"` and `"unreleasedFirst"`.',
    )


class CustomFieldContextDefaultValueTextArea(BaseModel):
    text: Optional[str] = Field(
        None, description='The default text. The maximum length is 32767 characters.'
    )
    type: Literal['textarea']


class CustomFieldContextDefaultValueTextField(BaseModel):
    text: Optional[str] = Field(
        None, description='The default text. The maximum length is 254 characters.'
    )
    type: Literal['textfield']


class CustomFieldContextDefaultValueURL(BaseModel):
    contextId: str = Field(..., description='The ID of the context.')
    type: Literal['url']
    url: str = Field(..., description='The default URL.')


class CustomFieldContextOption(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    disabled: bool = Field(..., description='Whether the option is disabled.')
    id: str = Field(..., description='The ID of the custom field option.')
    optionId: Optional[str] = Field(
        None,
        description='For cascading options, the ID of the custom field option containing the cascading option.',
    )
    value: str = Field(..., description='The value of the custom field option.')


class CustomFieldContextProjectMapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    contextId: str = Field(..., description='The ID of the context.')
    isGlobalContext: Optional[bool] = Field(
        None, description='Whether context is global.'
    )
    projectId: Optional[str] = Field(None, description='The ID of the project.')


class CustomFieldContextUpdateDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the custom field context. The maximum length is 255 characters.',
    )
    name: Optional[str] = Field(
        None,
        description='The name of the custom field context. The name must be unique. The maximum length is 255 characters.',
    )


class CustomFieldCreatedContextOptionsList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    options: Optional[List[CustomFieldContextOption]] = Field(
        None, description='The created custom field options.'
    )


class SearcherKey(Enum):
    com_atlassian_jira_plugin_system_customfieldtypes_cascadingselectsearcher = (
        'com.atlassian.jira.plugin.system.customfieldtypes:cascadingselectsearcher'
    )
    com_atlassian_jira_plugin_system_customfieldtypes_daterange = (
        'com.atlassian.jira.plugin.system.customfieldtypes:daterange'
    )
    com_atlassian_jira_plugin_system_customfieldtypes_datetimerange = (
        'com.atlassian.jira.plugin.system.customfieldtypes:datetimerange'
    )
    com_atlassian_jira_plugin_system_customfieldtypes_exactnumber = (
        'com.atlassian.jira.plugin.system.customfieldtypes:exactnumber'
    )
    com_atlassian_jira_plugin_system_customfieldtypes_exacttextsearcher = (
        'com.atlassian.jira.plugin.system.customfieldtypes:exacttextsearcher'
    )
    com_atlassian_jira_plugin_system_customfieldtypes_grouppickersearcher = (
        'com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher'
    )
    com_atlassian_jira_plugin_system_customfieldtypes_labelsearcher = (
        'com.atlassian.jira.plugin.system.customfieldtypes:labelsearcher'
    )
    com_atlassian_jira_plugin_system_customfieldtypes_multiselectsearcher = (
        'com.atlassian.jira.plugin.system.customfieldtypes:multiselectsearcher'
    )
    com_atlassian_jira_plugin_system_customfieldtypes_numberrange = (
        'com.atlassian.jira.plugin.system.customfieldtypes:numberrange'
    )
    com_atlassian_jira_plugin_system_customfieldtypes_projectsearcher = (
        'com.atlassian.jira.plugin.system.customfieldtypes:projectsearcher'
    )
    com_atlassian_jira_plugin_system_customfieldtypes_textsearcher = (
        'com.atlassian.jira.plugin.system.customfieldtypes:textsearcher'
    )
    com_atlassian_jira_plugin_system_customfieldtypes_userpickergroupsearcher = (
        'com.atlassian.jira.plugin.system.customfieldtypes:userpickergroupsearcher'
    )
    com_atlassian_jira_plugin_system_customfieldtypes_versionsearcher = (
        'com.atlassian.jira.plugin.system.customfieldtypes:versionsearcher'
    )


class CustomFieldDefinitionJsonBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the custom field, which is displayed in Jira.',
    )
    name: str = Field(
        ...,
        description='The name of the custom field, which is displayed in Jira. This is not the unique identifier.',
    )
    searcherKey: Optional[SearcherKey] = Field(
        None,
        description="The searcher defines the way the field is searched in Jira. For example, *com.atlassian.jira.plugin.system.customfieldtypes:grouppickersearcher*.  \nThe search UI (basic search and JQL search) will display different operations and values for the field, based on the field searcher. You must specify a searcher that is valid for the field type, as listed below (abbreviated values shown):\n\n *  `cascadingselect`: `cascadingselectsearcher`\n *  `datepicker`: `daterange`\n *  `datetime`: `datetimerange`\n *  `float`: `exactnumber` or `numberrange`\n *  `grouppicker`: `grouppickersearcher`\n *  `importid`: `exactnumber` or `numberrange`\n *  `labels`: `labelsearcher`\n *  `multicheckboxes`: `multiselectsearcher`\n *  `multigrouppicker`: `multiselectsearcher`\n *  `multiselect`: `multiselectsearcher`\n *  `multiuserpicker`: `userpickergroupsearcher`\n *  `multiversion`: `versionsearcher`\n *  `project`: `projectsearcher`\n *  `radiobuttons`: `multiselectsearcher`\n *  `readonlyfield`: `textsearcher`\n *  `select`: `multiselectsearcher`\n *  `textarea`: `textsearcher`\n *  `textfield`: `textsearcher`\n *  `url`: `exacttextsearcher`\n *  `userpicker`: `userpickergroupsearcher`\n *  `version`: `versionsearcher`\n\nIf no searcher is provided, the field isn't searchable. However, [Forge custom fields](https://developer.atlassian.com/platform/forge/manifest-reference/modules/#jira-custom-field-type--beta-) have a searcher set automatically, so are always searchable.",
    )
    type: str = Field(
        ...,
        description='The type of the custom field. These built-in custom field types are available:\n\n *  `cascadingselect`: Enables values to be selected from two levels of select lists (value: `com.atlassian.jira.plugin.system.customfieldtypes:cascadingselect`)\n *  `datepicker`: Stores a date using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:datepicker`)\n *  `datetime`: Stores a date with a time component (value: `com.atlassian.jira.plugin.system.customfieldtypes:datetime`)\n *  `float`: Stores and validates a numeric (floating point) input (value: `com.atlassian.jira.plugin.system.customfieldtypes:float`)\n *  `grouppicker`: Stores a user group using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:grouppicker`)\n *  `importid`: A read-only field that stores the ID the issue had in the system it was imported from (value: `com.atlassian.jira.plugin.system.customfieldtypes:importid`)\n *  `labels`: Stores labels (value: `com.atlassian.jira.plugin.system.customfieldtypes:labels`)\n *  `multicheckboxes`: Stores multiple values using checkboxes (value: ``)\n *  `multigrouppicker`: Stores multiple user groups using a picker control (value: ``)\n *  `multiselect`: Stores multiple values using a select list (value: `com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes`)\n *  `multiuserpicker`: Stores multiple users using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:multigrouppicker`)\n *  `multiversion`: Stores multiple versions from the versions available in a project using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:multiversion`)\n *  `project`: Stores a project from a list of projects that the user is permitted to view (value: `com.atlassian.jira.plugin.system.customfieldtypes:project`)\n *  `radiobuttons`: Stores a value using radio buttons (value: `com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons`)\n *  `readonlyfield`: Stores a read-only text value, which can only be populated via the API (value: `com.atlassian.jira.plugin.system.customfieldtypes:readonlyfield`)\n *  `select`: Stores a value from a configurable list of options (value: `com.atlassian.jira.plugin.system.customfieldtypes:select`)\n *  `textarea`: Stores a long text string using a multiline text area (value: `com.atlassian.jira.plugin.system.customfieldtypes:textarea`)\n *  `textfield`: Stores a text string using a single-line text box (value: `com.atlassian.jira.plugin.system.customfieldtypes:textfield`)\n *  `url`: Stores a URL (value: `com.atlassian.jira.plugin.system.customfieldtypes:url`)\n *  `userpicker`: Stores a user using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:userpicker`)\n *  `version`: Stores a version using a picker control (value: `com.atlassian.jira.plugin.system.customfieldtypes:version`)\n\nTo create a field based on a [Forge custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/#jira-custom-field-type--beta-), use the ID of the Forge custom field type as the value. For example, `ari:cloud:ecosystem::extension/e62f20a2-4b61-4dbe-bfb9-9a88b5e3ac84/548c5df1-24aa-4f7c-bbbb-3038d947cb05/static/my-cf-type-key`.',
    )


class CustomFieldOption(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    self: Optional[AnyUrl] = Field(
        None, description='The URL of these custom field option details.'
    )
    value: Optional[str] = Field(
        None, description='The value of the custom field option.'
    )


class CustomFieldOptionCreate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    disabled: Optional[bool] = Field(
        None, description='Whether the option is disabled.'
    )
    optionId: Optional[str] = Field(
        None,
        description='For cascading options, the ID of the custom field object containing the cascading option.',
    )
    value: str = Field(..., description='The value of the custom field option.')


class CustomFieldOptionUpdate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    disabled: Optional[bool] = Field(
        None, description='Whether the option is disabled.'
    )
    id: str = Field(..., description='The ID of the custom field option.')
    value: Optional[str] = Field(
        None, description='The value of the custom field option.'
    )


class CustomFieldReplacement(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    customFieldId: Optional[int_aliased] = Field(
        None,
        description='The ID of the custom field in which to replace the version number.',
    )
    moveTo: Optional[int_aliased] = Field(
        None,
        description='The version number to use as a replacement for the deleted version.',
    )


class CustomFieldUpdatedContextOptionsList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    options: Optional[List[CustomFieldOptionUpdate]] = Field(
        None, description='The updated custom field options.'
    )


class CustomFieldValueUpdate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueIds: List[int_aliased] = Field(..., description='The list of issue IDs.')
    value: Any = Field(
        ...,
        description='The value for the custom field. The value must be compatible with the [custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#data-types) as follows:\n\n *  `string` the value must be a string.\n *  `number` the value must be a number.\n *  `datetime` the value must be a string that represents a date in the ISO format or the simplified extended ISO format. For example, `"2023-01-18T12:00:00-03:00"` or `"2023-01-18T12:00:00.000Z"`. However, the milliseconds part is ignored.\n *  `user` the value must be an object that contains the `accountId` field.\n *  `group` the value must be an object that contains the group `name` or `groupId` field. Because group names can change, we recommend using `groupId`.\n\nA list of appropriate values must be provided if the field is of the `list` [collection type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#collection-types).',
    )


class CustomFieldValueUpdateDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    updates: Optional[List[CustomFieldValueUpdate]] = Field(
        None, description='The list of custom field update details.'
    )


class Color(Enum):
    blue = 'blue'
    red = 'red'
    yellow = 'yellow'
    green = 'green'
    cyan = 'cyan'
    purple = 'purple'
    gray = 'gray'
    white = 'white'


class DashboardGadgetPosition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    The_column_position_of_the_gadget_: int_aliased = Field(
        ..., alias='The column position of the gadget.'
    )
    The_row_position_of_the_gadget_: int_aliased = Field(
        ..., alias='The row position of the gadget.'
    )


class DashboardGadgetSettings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    color: Optional[str] = Field(
        None,
        description='The color of the gadget. Should be one of `blue`, `red`, `yellow`, `green`, `cyan`, `purple`, `gray`, or `white`.',
    )
    ignoreUriAndModuleKeyValidation: Optional[bool] = Field(
        None,
        description="Whether to ignore the validation of module key and URI. For example, when a gadget is created that is a part of an application that isn't installed.",
    )
    moduleKey: Optional[str] = Field(
        None,
        description="The module key of the gadget type. Can't be provided with `uri`.",
    )
    position: Optional[DashboardGadgetPosition] = Field(
        None,
        description='The position of the gadget. When the gadget is placed into the position, other gadgets in the same column are moved down to accommodate it.',
    )
    title: Optional[str] = Field(None, description='The title of the gadget.')
    uri: Optional[str] = Field(
        None,
        description="The URI of the gadget type. Can't be provided with `moduleKey`.",
    )


class DashboardGadgetUpdateRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    color: Optional[str] = Field(
        None,
        description='The color of the gadget. Should be one of `blue`, `red`, `yellow`, `green`, `cyan`, `purple`, `gray`, or `white`.',
    )
    position: Optional[DashboardGadgetPosition] = Field(
        None, description='The position of the gadget.'
    )
    title: Optional[str] = Field(None, description='The title of the gadget.')


class Scope1(Enum):
    GLOBAL = 'GLOBAL'
    AUTHENTICATED = 'AUTHENTICATED'
    PRIVATE = 'PRIVATE'


class DefaultShareScope(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    scope: Scope1 = Field(
        ...,
        description='The scope of the default sharing for new filters and dashboards:\n\n *  `AUTHENTICATED` Shared with all logged-in users.\n *  `GLOBAL` Shared with all logged-in users. This shows as `AUTHENTICATED` in the response.\n *  `PRIVATE` Not shared with any users.',
    )


class DefaultWorkflow(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    updateDraftIfNeeded: Optional[bool] = Field(
        None,
        description='Whether a draft workflow scheme is created or updated when updating an active workflow scheme. The draft is updated with the new default workflow. Defaults to `false`.',
    )
    workflow: str = Field(
        ..., description='The name of the workflow to set as the default workflow.'
    )


class DeleteAndReplaceVersionBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    customFieldReplacementList: Optional[List[CustomFieldReplacement]] = Field(
        None,
        description='An array of custom field IDs (`customFieldId`) and version IDs (`moveTo`) to update when the fields contain the deleted version.',
    )
    moveAffectedIssuesTo: Optional[int_aliased] = Field(
        None,
        description='The ID of the version to update `affectedVersion` to when the field contains the deleted version.',
    )
    moveFixIssuesTo: Optional[int_aliased] = Field(
        None,
        description='The ID of the version to update `fixVersion` to when the field contains the deleted version.',
    )


class EntityProperty(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    key: Optional[str] = Field(
        None, description='The key of the property. Required on create and update.'
    )
    value: Optional[Any] = Field(
        None, description='The value of the property. Required on create and update.'
    )


class EntityPropertyDetails(BaseModel):
    entityId: float = Field(..., description='The entity property ID.', examples=[123])
    key: str = Field(..., description='The entity property key.', examples=['mykey'])
    value: str = Field(
        ..., description='The new value of the entity property.', examples=['newValue']
    )


class ErrorCollection(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    errorMessages: Optional[List[str]] = Field(
        None,
        description='The list of error messages produced by this operation. For example, "input parameter \'key\' must be provided"',
    )
    errors: Optional[Dict[str, str]] = Field(
        None,
        description='The list of errors by parameter returned by the operation. For example,"projectKey": "Project keys must start with an uppercase letter, followed by one or more uppercase alphanumeric characters."',
    )
    status: Optional[int_aliased] = None


class ErrorMessage(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    message: str = Field(..., description='The error message.')


class NotificationType(Enum):
    CurrentAssignee = 'CurrentAssignee'
    Reporter = 'Reporter'
    CurrentUser = 'CurrentUser'
    ProjectLead = 'ProjectLead'
    ComponentLead = 'ComponentLead'
    User = 'User'
    Group = 'Group'
    ProjectRole = 'ProjectRole'
    EmailAddress = 'EmailAddress'
    AllWatchers = 'AllWatchers'
    UserCustomField = 'UserCustomField'
    GroupCustomField = 'GroupCustomField'


class FailedWebhook(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    body: Optional[str] = Field(None, description='The webhook body.')
    failureTime: int_aliased = Field(
        ...,
        description='The time the webhook was added to the list of failed webhooks (that is, the time of the last failed retry).',
    )
    id: str = Field(
        ...,
        description='The webhook ID, as sent in the `X-Atlassian-Webhook-Identifier` header with the webhook.',
    )
    url: str = Field(..., description='The original webhook destination.')


class FailedWebhooks(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    maxResults: int_aliased = Field(
        ...,
        description='The maximum number of items on the page. If the list of values is shorter than this number, then there are no more pages.',
    )
    next: Optional[AnyUrl] = Field(
        None,
        description='The URL to the next page of results. Present only if the request returned at least one result.The next page may be empty at the time of receiving the response, but new failed webhooks may appear in time. You can save the URL to the next page and query for new results periodically (for example, every hour).',
    )
    values: List[FailedWebhook] = Field(..., description='The list of webhooks.')


class Operator2(Enum):
    changed = 'changed'


class FieldConfiguration(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: str = Field(
        ..., description='The description of the field configuration.'
    )
    id: int_aliased = Field(..., description='The ID of the field configuration.')
    isDefault: Optional[bool] = Field(
        None, description='Whether the field configuration is the default.'
    )
    name: str = Field(..., description='The name of the field configuration.')


class FieldConfigurationDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[constr(max_length=255)] = Field(
        None, description='The description of the field configuration.'
    )
    name: constr(max_length=255) = Field(
        ..., description='The name of the field configuration. Must be unique.'
    )


class FieldConfigurationIssueTypeItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fieldConfigurationId: str = Field(
        ..., description='The ID of the field configuration.'
    )
    fieldConfigurationSchemeId: str = Field(
        ..., description='The ID of the field configuration scheme.'
    )
    issueTypeId: str = Field(
        ...,
        description='The ID of the issue type or *default*. When set to *default* this field configuration issue type item applies to all issue types without a field configuration.',
    )


class FieldConfigurationItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the field within the field configuration.'
    )
    id: str = Field(
        ..., description='The ID of the field within the field configuration.'
    )
    isHidden: Optional[bool] = Field(
        None, description='Whether the field is hidden in the field configuration.'
    )
    isRequired: Optional[bool] = Field(
        None, description='Whether the field is required in the field configuration.'
    )
    renderer: Optional[str] = Field(
        None,
        description='The renderer type for the field within the field configuration.',
    )


class FieldConfigurationItemsDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fieldConfigurationItems: List[FieldConfigurationItem] = Field(
        ..., description='Details of fields in a field configuration.'
    )


class FieldConfigurationScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the field configuration scheme.'
    )
    id: str = Field(..., description='The ID of the field configuration scheme.')
    name: str = Field(..., description='The name of the field configuration scheme.')


class FieldConfigurationSchemeProjectAssociation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fieldConfigurationSchemeId: Optional[str] = Field(
        None,
        description='The ID of the field configuration scheme. If the field configuration scheme ID is `null`, the operation assigns the default field configuration scheme.',
    )
    projectId: str = Field(..., description='The ID of the project.')


class FieldConfigurationSchemeProjects(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fieldConfigurationScheme: Optional[FieldConfigurationScheme] = None
    projectIds: List[str] = Field(
        ..., description='The IDs of projects using the field configuration scheme.'
    )


class FieldConfigurationToIssueTypeMapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fieldConfigurationId: str = Field(
        ..., description='The ID of the field configuration.'
    )
    issueTypeId: str = Field(
        ...,
        description='The ID of the issue type or *default*. When set to *default* this field configuration issue type item applies to all issue types without a field configuration. An issue type can be included only once in a request.',
    )


class Type1(Enum):
    TRACKED = 'TRACKED'
    NOT_TRACKED = 'NOT_TRACKED'
    NO_INFORMATION = 'NO_INFORMATION'


class FieldLastUsed(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Optional[Type1] = Field(
        None,
        description='Last used value type:\n\n *  *TRACKED*: field is tracked and a last used date is available.\n *  *NOT\\_TRACKED*: field is not tracked, last used date is not available.\n *  *NO\\_INFORMATION*: field is tracked, but no last used date is available.',
    )
    value: Optional[datetime] = Field(
        None, description='The date when the value of the field last changed.'
    )


class Auto(Enum):
    true = 'true'
    false = 'false'


class Deprecated(Enum):
    true = 'true'
    false = 'false'


class Orderable(Enum):
    true = 'true'
    false = 'false'


class Searchable(Enum):
    true = 'true'
    false = 'false'


class FieldReferenceData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    auto: Optional[Auto] = Field(
        None, description='Whether the field provide auto-complete suggestions.'
    )
    cfid: Optional[str] = Field(
        None, description='If the item is a custom field, the ID of the custom field.'
    )
    deprecated: Optional[Deprecated] = Field(
        None, description='Whether this field has been deprecated.'
    )
    deprecatedSearcherKey: Optional[str] = Field(
        None,
        description='The searcher key of the field, only passed when the field is deprecated.',
    )
    displayName: Optional[str] = Field(
        None,
        description='The display name contains the following:\n\n *  for system fields, the field name. For example, `Summary`.\n *  for collapsed custom fields, the field name followed by a hyphen and then the field name and field type. For example, `Component - Component[Dropdown]`.\n *  for other custom fields, the field name followed by a hyphen and then the custom field ID. For example, `Component - cf[10061]`.',
    )
    operators: Optional[List[str]] = Field(
        None, description='The valid search operators for the field.'
    )
    orderable: Optional[Orderable] = Field(
        None,
        description="Whether the field can be used in a query's `ORDER BY` clause.",
    )
    searchable: Optional[Searchable] = Field(
        None, description='Whether the content of this field can be searched.'
    )
    types: Optional[List[str]] = Field(
        None, description='The data types of items in the field.'
    )
    value: Optional[str] = Field(None, description='The field identifier.')


class FieldUpdateOperation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    add: Optional[Any] = Field(
        None, description='The value to add to the field.', examples=['triaged']
    )
    copy_: Optional[Any] = Field(
        None,
        alias='copy',
        description='The field value to copy from another issue.',
        examples=[{'issuelinks': {'sourceIssues': [{'key': 'FP-5'}]}}],
    )
    edit: Optional[Any] = Field(
        None,
        description='The value to edit in the field.',
        examples=[{'originalEstimate': '1w 1d', 'remainingEstimate': '4d'}],
    )
    remove: Optional[Any] = Field(
        None, description='The value to removed from the field.', examples=['blocker']
    )
    set: Optional[Any] = Field(
        None, description='The value to set in the field.', examples=['A new summary']
    )


class Operator3(Enum):
    field_ = '='
    field__ = '!='
    field__1 = '>'
    field__2 = '<'
    field___1 = '>='
    field___2 = '<='
    in_ = 'in'
    not_in = 'not in'
    field__3 = '~'
    field___3 = '~='
    is_ = 'is'
    is_not = 'is not'


class Operator4(Enum):
    was = 'was'
    was_in = 'was in'
    was_not_in = 'was not in'
    was_not = 'was not'


class FunctionOperand(BaseModel):
    arguments: List[str] = Field(..., description='The list of function arguments.')
    encodedOperand: Optional[str] = Field(
        None, description='Encoded operand, which can be used directly in a JQL query.'
    )
    function: str = Field(..., description='The name of the function.')


class IsList(Enum):
    true = 'true'
    false = 'false'


class FunctionReferenceData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    displayName: Optional[str] = Field(
        None, description='The display name of the function.'
    )
    isList: Optional[IsList] = Field(
        None, description='Whether the function can take a list of arguments.'
    )
    types: Optional[List[str]] = Field(
        None, description='The data types returned by the function.'
    )
    value: Optional[str] = Field(None, description='The function identifier.')


class Attribute(Enum):
    notSelectable = 'notSelectable'
    defaultValue = 'defaultValue'


class GlobalScopeBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    attributes: Optional[List[Attribute]] = Field(
        None,
        description="Defines the behavior of the option in the global context.If notSelectable is set, the option cannot be set as the field's value. This is useful for archiving an option that has previously been selected but shouldn't be used anymore.If defaultValue is set, the option is selected by default.",
    )


class GroupDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    groupId: Optional[str] = Field(
        None,
        description='The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.',
    )
    name: Optional[str] = Field(None, description='The name of the group.')


class Type2(Enum):
    ADMIN = 'ADMIN'
    SINGLE = 'SINGLE'
    MULTIPLE = 'MULTIPLE'


class GroupLabel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    text: Optional[str] = Field(None, description='The group label name.')
    title: Optional[str] = Field(None, description='The title of the group label.')
    type: Optional[Type2] = Field(None, description='The type of the group label.')


class GroupName(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    groupId: Optional[str] = Field(
        None,
        description='The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.',
    )
    name: Optional[str] = Field(None, description='The name of group.')
    self: Optional[AnyUrl] = Field(None, description='The URL for these group details.')


class HealthCheckResult(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the Jira health check item.'
    )
    name: Optional[str] = Field(
        None, description='The name of the Jira health check item.'
    )
    passed: Optional[bool] = Field(
        None, description='Whether the Jira health check item passed or failed.'
    )


class HistoryMetadataParticipant(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    avatarUrl: Optional[str] = Field(
        None,
        description='The URL to an avatar for the user or system associated with a history record.',
    )
    displayName: Optional[str] = Field(
        None,
        description='The display name of the user or system associated with a history record.',
    )
    displayNameKey: Optional[str] = Field(
        None,
        description='The key of the display name of the user or system associated with a history record.',
    )
    id: Optional[str] = Field(
        None,
        description='The ID of the user or system associated with a history record.',
    )
    type: Optional[str] = Field(
        None,
        description='The type of the user or system associated with a history record.',
    )
    url: Optional[str] = Field(
        None,
        description='The URL of the user or system associated with a history record.',
    )


class Icon(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    link: Optional[str] = Field(
        None,
        description='The URL of the tooltip, used only for a status icon. If not set, the status icon in Jira is not clickable.',
    )
    title: Optional[str] = Field(
        None,
        description='The title of the icon. This is used as follows:\n\n *  For a status icon it is used as a tooltip on the icon. If not set, the status icon doesn\'t display a tooltip in Jira.\n *  For the remote object icon it is used in conjunction with the application name to display a tooltip for the link\'s icon. The tooltip takes the format "\\[application name\\] icon title". Blank itemsare excluded from the tooltip title. If both items are blank, the icon tooltop displays as "Web Link".',
    )
    url16x16: Optional[str] = Field(
        None, description='The URL of an icon that displays at 16x16 pixel in Jira.'
    )


class IconBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    link: Optional[str] = Field(
        None, description='The URL of the tooltip, used only for a status icon.'
    )
    title: Optional[str] = Field(
        None, description='The title of the icon, for use as a tooltip on the icon.'
    )
    url16x16: Optional[str] = Field(None, description='The URL of a 16x16 pixel icon.')


class IdBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: int_aliased = Field(
        ...,
        description='The ID of the permission scheme to associate with the project. Use the [Get all permission schemes](#api-rest-api-3-permissionscheme-get) resource to get a list of permission scheme IDs.',
    )


class IdOrKeyBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[int_aliased] = Field(
        None, description='The ID of the referenced item.'
    )
    key: Optional[str] = Field(None, description='The key of the referenced item.')


class IncludedFields(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    actuallyIncluded: Optional[List[str]] = None
    excluded: Optional[List[str]] = None
    included: Optional[List[str]] = None


class IssueChangelogIds(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    changelogIds: List[int_aliased] = Field(
        ..., description='The list of changelog IDs.'
    )


class IssueCommentListRequestBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ids: List[int_aliased] = Field(
        ...,
        description='The list of comment IDs. A maximum of 1000 IDs can be specified.',
    )


class IssueContextVariable(BaseModel):
    id: Optional[int_aliased] = Field(None, description='The issue ID.')
    key: Optional[str] = Field(None, description='The issue key.')
    type: str = Field(..., description='Type of custom context variable.')


class IssueEvent(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the event.')
    name: Optional[str] = Field(None, description='The name of the event.')


class IssueFilterForBulkPropertyDelete(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    currentValue: Optional[Any] = Field(
        None, description='The value of properties to perform the bulk operation on.'
    )
    entityIds: Optional[List[int_aliased]] = Field(
        None, description='List of issues to perform the bulk delete operation on.'
    )


class IssueFilterForBulkPropertySet(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    currentValue: Optional[Any] = Field(
        None, description='The value of properties to perform the bulk operation on.'
    )
    entityIds: Optional[List[int_aliased]] = Field(
        None, description='List of issues to perform the bulk operation on.'
    )
    hasProperty: Optional[bool] = Field(
        None,
        description='Whether the bulk operation occurs only when the property is present on or absent from an issue.',
    )


class IssueLinkType(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(
        None,
        description="The ID of the issue link type and is used as follows:\n\n *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is the type of issue link. Required on create when `name` isn't provided. Otherwise, read only.\n *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is read only.",
    )
    inward: Optional[str] = Field(
        None,
        description='The description of the issue link type inward link and is used as follows:\n\n *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is read only.\n *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is required on create and optional on update. Otherwise, read only.',
    )
    name: Optional[str] = Field(
        None,
        description="The name of the issue link type and is used as follows:\n\n *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is the type of issue link. Required on create when `id` isn't provided. Otherwise, read only.\n *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is required on create and optional on update. Otherwise, read only.",
    )
    outward: Optional[str] = Field(
        None,
        description='The description of the issue link type outward link and is used as follows:\n\n *  In the [ issueLink](#api-rest-api-3-issueLink-post) resource it is read only.\n *  In the [ issueLinkType](#api-rest-api-3-issueLinkType-post) resource it is required on create and optional on update. Otherwise, read only.',
    )
    self: Optional[AnyUrl] = Field(
        None, description='The URL of the issue link type. Read only.'
    )


class IssueLinkTypes(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueLinkTypes: Optional[List[IssueLinkType]] = Field(
        None, description='The issue link type bean.'
    )


class IssueList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueIds: List[str] = Field(..., description='The list of issue IDs.')


class IssueMatchesForJQL(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    errors: List[str] = Field(..., description='A list of errors.')
    matchedIssues: List[int_aliased] = Field(..., description='A list of issue IDs.')


class Type3(Enum):
    subtask = 'subtask'
    standard = 'standard'


class IssueTypeCreateBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the issue type.'
    )
    hierarchyLevel: Optional[int_aliased] = Field(
        None,
        description='The hierarchy level of the issue type. Use:\n\n *  `-1` for Subtask.\n *  `0` for Base.\n\nDefaults to `0`.',
    )
    name: str = Field(
        ...,
        description='The unique name for the issue type. The maximum length is 60 characters.',
    )
    type: Optional[Type3] = Field(
        None,
        description='Deprecated. Use `hierarchyLevel` instead. See the [deprecation notice](https://community.developer.atlassian.com/t/deprecation-of-the-epic-link-parent-link-and-other-related-fields-in-rest-apis-and-webhooks/54048) for details.\n\nWhether the issue type is `subtype` or `standard`. Defaults to `standard`.',
    )


class IssueTypeIds(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeIds: List[str] = Field(..., description='The list of issue type IDs.')


class IssueTypeIdsToRemove(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeIds: List[str] = Field(
        ...,
        description='The list of issue type IDs. Must contain unique values not longer than 255 characters and not be empty. Maximum of 100 IDs.',
    )


class IssueTypeInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    avatarId: Optional[int_aliased] = Field(
        None, description='The avatar of the issue type.'
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the issue type.')
    name: Optional[str] = Field(None, description='The name of the issue type.')


class IssueTypeScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    defaultIssueTypeId: Optional[str] = Field(
        None, description='The ID of the default issue type of the issue type scheme.'
    )
    description: Optional[str] = Field(
        None, description='The description of the issue type scheme.'
    )
    id: str = Field(..., description='The ID of the issue type scheme.')
    isDefault: Optional[bool] = Field(
        None, description='Whether the issue type scheme is the default.'
    )
    name: str = Field(..., description='The name of the issue type scheme.')


class IssueTypeSchemeDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    defaultIssueTypeId: Optional[str] = Field(
        None,
        description='The ID of the default issue type of the issue type scheme. This ID must be included in `issueTypeIds`.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the issue type scheme. The maximum length is 4000 characters.',
    )
    issueTypeIds: List[str] = Field(
        ...,
        description='The list of issue types IDs of the issue type scheme. At least one standard issue type ID is required.',
    )
    name: str = Field(
        ...,
        description='The name of the issue type scheme. The name must be unique. The maximum length is 255 characters.',
    )


class IssueTypeSchemeID(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeSchemeId: str = Field(..., description='The ID of the issue type scheme.')


class IssueTypeSchemeMapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeId: str = Field(..., description='The ID of the issue type.')
    issueTypeSchemeId: str = Field(..., description='The ID of the issue type scheme.')


class IssueTypeSchemeProjectAssociation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeSchemeId: str = Field(..., description='The ID of the issue type scheme.')
    projectId: str = Field(..., description='The ID of the project.')


class IssueTypeSchemeProjects(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeScheme: IssueTypeScheme = Field(
        ..., description='Details of an issue type scheme.'
    )
    projectIds: List[str] = Field(
        ..., description='The IDs of the projects using the issue type scheme.'
    )


class IssueTypeSchemeUpdateDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    defaultIssueTypeId: Optional[str] = Field(
        None, description='The ID of the default issue type of the issue type scheme.'
    )
    description: Optional[str] = Field(
        None,
        description='The description of the issue type scheme. The maximum length is 4000 characters.',
    )
    name: Optional[str] = Field(
        None,
        description='The name of the issue type scheme. The name must be unique. The maximum length is 255 characters.',
    )


class IssueTypeScreenScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the issue type screen scheme.'
    )
    id: str = Field(..., description='The ID of the issue type screen scheme.')
    name: str = Field(..., description='The name of the issue type screen scheme.')


class IssueTypeScreenSchemeId(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(..., description='The ID of the issue type screen scheme.')


class IssueTypeScreenSchemeItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeId: str = Field(
        ...,
        description="The ID of the issue type or *default*. Only issue types used in classic projects are accepted. When creating an issue screen scheme, an entry for *default* must be provided and defines the mapping for all issue types without a screen scheme. Otherwise, a *default* entry can't be provided.",
    )
    issueTypeScreenSchemeId: str = Field(
        ..., description='The ID of the issue type screen scheme.'
    )
    screenSchemeId: str = Field(..., description='The ID of the screen scheme.')


class IssueTypeScreenSchemeMapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeId: str = Field(
        ...,
        description='The ID of the issue type or *default*. Only issue types used in classic projects are accepted. An entry for *default* must be provided and defines the mapping for all issue types without a screen scheme.',
    )
    screenSchemeId: str = Field(
        ...,
        description='The ID of the screen scheme. Only screen schemes used in classic projects are accepted.',
    )


class IssueTypeScreenSchemeMappingDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeMappings: List[IssueTypeScreenSchemeMapping] = Field(
        ...,
        description='The list of issue type to screen scheme mappings. A *default* entry cannot be specified because a default entry is added when an issue type screen scheme is created.',
    )


class IssueTypeScreenSchemeProjectAssociation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeScreenSchemeId: Optional[str] = Field(
        None, description='The ID of the issue type screen scheme.'
    )
    projectId: Optional[str] = Field(None, description='The ID of the project.')


class IssueTypeScreenSchemeUpdateDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the issue type screen scheme. The maximum length is 255 characters.',
    )
    name: Optional[str] = Field(
        None,
        description='The name of the issue type screen scheme. The name must be unique. The maximum length is 255 characters.',
    )


class IssueTypeScreenSchemesProjects(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeScreenScheme: IssueTypeScreenScheme = Field(
        ..., description='Details of an issue type screen scheme.'
    )
    projectIds: List[str] = Field(
        ..., description='The IDs of the projects using the issue type screen scheme.'
    )


class IssueTypeToContextMapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    contextId: str = Field(..., description='The ID of the context.')
    isAnyIssueType: Optional[bool] = Field(
        None, description='Whether the context is mapped to any issue type.'
    )
    issueTypeId: Optional[str] = Field(None, description='The ID of the issue type.')


class IssueTypeUpdateBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    avatarId: Optional[int_aliased] = Field(
        None, description='The ID of an issue type avatar.'
    )
    description: Optional[str] = Field(
        None, description='The description of the issue type.'
    )
    name: Optional[str] = Field(
        None,
        description='The unique name for the issue type. The maximum length is 60 characters.',
    )


class IssueTypeWorkflowMapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueType: Optional[str] = Field(
        None,
        description='The ID of the issue type. Not required if updating the issue type-workflow mapping.',
    )
    updateDraftIfNeeded: Optional[bool] = Field(
        None,
        description='Set to true to create or update the draft of a workflow scheme and update the mapping in the draft, when the workflow scheme cannot be edited. Defaults to `false`. Only applicable when updating the workflow-issue types mapping.',
    )
    workflow: Optional[str] = Field(None, description='The name of the workflow.')


class IssueTypesWorkflowMapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    defaultMapping: Optional[bool] = Field(
        None,
        description='Whether the workflow is the default workflow for the workflow scheme.',
    )
    issueTypes: Optional[List[str]] = Field(
        None, description='The list of issue type IDs.'
    )
    updateDraftIfNeeded: Optional[bool] = Field(
        None,
        description='Whether a draft workflow scheme is created or updated when updating an active workflow scheme. The draft is updated with the new workflow-issue types mapping. Defaults to `false`.',
    )
    workflow: Optional[str] = Field(
        None,
        description='The name of the workflow. Optional if updating the workflow-issue types mapping.',
    )


class IssuesAndJQLQueries(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueIds: List[int_aliased] = Field(..., description='A list of issue IDs.')
    jqls: List[str] = Field(..., description='A list of JQL queries.')


class IssuesJqlMetaDataBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    count: int_aliased = Field(
        ..., description='The number of issues that were loaded in this evaluation.'
    )
    maxResults: int_aliased = Field(
        ...,
        description='The maximum number of issues that could be loaded in this evaluation.',
    )
    startAt: int_aliased = Field(..., description='The index of the first issue.')
    totalCount: int_aliased = Field(
        ..., description='The total number of issues the JQL returned.'
    )
    validationWarnings: Optional[List[str]] = Field(
        None,
        description='Any warnings related to the JQL query. Present only if the validation mode was set to `warn`.',
    )


class IssuesMetaBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    jql: Optional[IssuesJqlMetaDataBean] = None


class JQLPersonalDataMigrationRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    queryStrings: Optional[List[str]] = Field(
        None,
        description='A list of queries with user identifiers. Maximum of 100 queries.',
    )


class JQLQueryWithUnknownUsers(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    convertedQuery: Optional[str] = Field(
        None,
        description="The converted query, with accountIDs instead of user identifiers, or 'unknown' for users that could not be found",
    )
    originalQuery: Optional[str] = Field(
        None, description='The original query, for reference'
    )


class JQLReferenceData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    jqlReservedWords: Optional[List[str]] = Field(
        None, description='List of JQL query reserved words.'
    )
    visibleFieldNames: Optional[List[FieldReferenceData]] = Field(
        None, description='List of fields usable in JQL queries.'
    )
    visibleFunctionNames: Optional[List[FunctionReferenceData]] = Field(
        None, description='List of functions usable in JQL queries.'
    )


class Validation(Enum):
    strict = 'strict'
    warn = 'warn'
    none = 'none'


class JexpJqlIssues(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    maxResults: Optional[int_aliased] = Field(
        None,
        description='The maximum number of issues to return from the JQL query. Inspect `meta.issues.jql.maxResults` in the response to ensure the maximum value has not been exceeded.',
    )
    query: Optional[str] = Field(None, description='The JQL query.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first issue to return from the JQL query.'
    )
    validation: Optional[Validation] = Field(
        'strict',
        description='Determines how to validate the JQL query and treat the validation results.',
    )


class JiraExpressionComplexity(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expensiveOperations: str = Field(
        ...,
        description='Information that can be used to determine how many [expensive operations](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#expensive-operations) the evaluation of the expression will perform. This information may be a formula or number. For example:\n\n *  `issues.map(i => i.comments)` performs as many expensive operations as there are issues on the issues list. So this parameter returns `N`, where `N` is the size of issue list.\n *  `new Issue(10010).comments` gets comments for one issue, so its complexity is `2` (`1` to retrieve issue 10010 from the database plus `1` to get its comments).',
    )
    variables: Optional[Dict[str, str]] = Field(
        None,
        description='Variables used in the formula, mapped to the parts of the expression they refer to.',
    )


class JiraExpressionForAnalysis(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    contextVariables: Optional[Dict[str, str]] = Field(
        None,
        description='Context variables and their types. The type checker assumes that [common context variables](https://developer.atlassian.com/cloud/jira/platform/jira-expressions/#context-variables), such as `issue` or `project`, are available in context and sets their type. Use this property to override the default types or provide details of new variables.',
    )
    expressions: List[str] = Field(
        ...,
        description='The list of Jira expressions to analyse.',
        examples=["issues.map(issue => issue.properties['property_key'])"],
    )


class Type4(Enum):
    syntax = 'syntax'
    type = 'type'
    other = 'other'


class JiraExpressionValidationError(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    column: Optional[int_aliased] = Field(
        None, description='The text column in which the error occurred.'
    )
    expression: Optional[str] = Field(
        None, description='The part of the expression in which the error occurred.'
    )
    line: Optional[int_aliased] = Field(
        None, description='The text line in which the error occurred.'
    )
    message: str = Field(
        ...,
        description='Details about the error.',
        examples=[
            '!, -, typeof, (, IDENTIFIER, null, true, false, NUMBER, STRING, TEMPLATE_LITERAL, new, [ or { expected, > encountered.'
        ],
    )
    type: Type4 = Field(..., description='The error type.')


class JiraExpressionsComplexityValueBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    limit: int_aliased = Field(
        ...,
        description='The maximum allowed complexity. The evaluation will fail if this value is exceeded.',
    )
    value: int_aliased = Field(
        ..., description='The complexity value of the current expression.'
    )


class StatusCategory(Enum):
    TODO = 'TODO'
    IN_PROGRESS = 'IN_PROGRESS'
    DONE = 'DONE'


class JqlFunctionPrecomputationBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    arguments: Optional[List[str]] = None
    created: Optional[datetime] = None
    field: Optional[str] = None
    functionKey: Optional[str] = None
    functionName: Optional[str] = None
    id: Optional[str] = None
    operator: Optional[str] = None
    updated: Optional[datetime] = None
    used: Optional[datetime] = None
    value: Optional[str] = None


class JqlFunctionPrecomputationUpdateBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: int_aliased
    value: str


class JqlFunctionPrecomputationUpdateRequestBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    values: Optional[List[JqlFunctionPrecomputationUpdateBean]] = None


class Query(RootModel[constr(min_length=1)]):
    root: constr(min_length=1)


class JqlQueriesToParse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    queries: List[Query] = Field(
        ..., description='A list of queries to parse.', min_length=1
    )


class Operator5(Enum):
    before = 'before'
    after = 'after'
    from_ = 'from'
    to = 'to'
    on = 'on'
    during = 'during'
    by = 'by'


class Type5(Enum):
    number = 'number'
    string = 'string'
    text = 'text'
    date = 'date'
    user = 'user'


class JqlQueryFieldEntityProperty(BaseModel):
    entity: str = Field(
        ..., description='The object on which the property is set.', examples=['issue']
    )
    key: str = Field(..., description='The key of the property.', examples=['stats'])
    path: str = Field(
        ...,
        description='The path in the property value to query.',
        examples=['comments.count'],
    )
    type: Optional[Type5] = Field(
        None,
        description='The type of the property value extraction. Not available if the extraction for the property is not registered on the instance with the [Entity property](https://developer.atlassian.com/cloud/jira/platform/modules/entity-property/) module.',
        examples=['number'],
    )


class Direction(Enum):
    asc = 'asc'
    desc = 'desc'


class JqlQueryToSanitize(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountId: Optional[constr(max_length=128)] = Field(
        None,
        description='The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.',
    )
    query: str = Field(..., description='The query to sanitize.')


class JsonContextVariable(BaseModel):
    type: str = Field(..., description='Type of custom context variable.')
    value: Optional[Dict[str, Any]] = Field(
        None, description='A JSON object containing custom content.'
    )


class NumberType(Enum):
    INT = 'INT'
    LONG = 'LONG'
    BIG_INTEGER = 'BIG_INTEGER'
    FLOAT = 'FLOAT'
    DOUBLE = 'DOUBLE'
    BIG_DECIMAL = 'BIG_DECIMAL'


class JsonNode(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    array: Optional[bool] = None
    bigDecimal: Optional[bool] = None
    bigInteger: Optional[bool] = None
    bigIntegerValue: Optional[int_aliased] = None
    binary: Optional[bool] = None
    binaryValue: Optional[List[str]] = None
    boolean: Optional[bool] = None
    booleanValue: Optional[bool] = None
    containerNode: Optional[bool] = None
    decimalValue: Optional[float] = None
    double: Optional[bool] = None
    doubleValue: Optional[float] = None
    elements: Optional[Dict[str, Any]] = None
    fieldNames: Optional[Dict[str, Any]] = None
    fields: Optional[Dict[str, Any]] = None
    floatingPointNumber: Optional[bool] = None
    int: Optional[bool] = None
    intValue: Optional[int_aliased] = None
    integralNumber: Optional[bool] = None
    long: Optional[bool] = None
    longValue: Optional[int_aliased] = None
    missingNode: Optional[bool] = None
    null: Optional[bool] = None
    number: Optional[bool] = None
    numberType: Optional[NumberType] = None
    numberValue: Optional[float] = None
    object: Optional[bool] = None
    pojo: Optional[bool] = None
    textValue: Optional[str] = None
    textual: Optional[bool] = None
    valueAsBoolean: Optional[bool] = None
    valueAsDouble: Optional[float] = None
    valueAsInt: Optional[int_aliased] = None
    valueAsLong: Optional[int_aliased] = None
    valueAsText: Optional[str] = None
    valueNode: Optional[bool] = None


class JsonTypeBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    configuration: Optional[Dict[str, Any]] = Field(
        None,
        description='If the field is a custom field, the configuration of the field.',
    )
    custom: Optional[str] = Field(
        None, description='If the field is a custom field, the URI of the field.'
    )
    customId: Optional[int_aliased] = Field(
        None, description='If the field is a custom field, the custom ID of the field.'
    )
    items: Optional[str] = Field(
        None,
        description='When the data type is an array, the name of the field items within the array.',
    )
    system: Optional[str] = Field(
        None, description='If the field is a system field, the name of the field.'
    )
    type: str = Field(..., description='The data type of the field.')


class Keyword(Enum):
    empty = 'empty'


class KeywordOperand(BaseModel):
    keyword: Keyword = Field(..., description='The keyword that is the operand value.')


class LicenseMetric(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    key: Optional[str] = Field(None, description='The key of the license metric.')
    value: Optional[str] = Field(None, description='The value for the license metric.')


class Plan(Enum):
    UNLICENSED = 'UNLICENSED'
    FREE = 'FREE'
    PAID = 'PAID'


class LicensedApplication(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(..., description='The ID of the application.')
    plan: Plan = Field(..., description='The licensing plan.')


class ListWrapperCallbackApplicationRole(BaseModel):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class ListWrapperCallbackGroupName(BaseModel):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class Locale(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    locale: Optional[str] = Field(
        None,
        description='The locale code. The Java the locale format is used: a two character language code (ISO 639), an underscore, and two letter country code (ISO 3166). For example, en\\_US represents a locale of English (United States). Required on create.',
    )


class Position(Enum):
    Earlier = 'Earlier'
    Later = 'Later'
    First = 'First'
    Last = 'Last'


class MoveFieldBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    after: Optional[AnyUrl] = Field(
        None,
        description="The ID of the screen tab field after which to place the moved screen tab field. Required if `position` isn't provided.",
    )
    position: Optional[Position] = Field(
        None,
        description="The named position to which the screen tab field should be moved. Required if `after` isn't provided.",
    )


class MultipleCustomFieldValuesUpdate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    customField: str = Field(
        ...,
        description='The ID or key of the custom field. For example, `customfield_10010`.',
    )
    issueIds: List[int_aliased] = Field(..., description='The list of issue IDs.')
    value: Any = Field(
        ...,
        description='The value for the custom field. The value must be compatible with the [custom field type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#data-types) as follows:\n\n *  `string` the value must be a string.\n *  `number` the value must be a number.\n *  `datetime` the value must be a string that represents a date in the ISO format or the simplified extended ISO format. For example, `"2023-01-18T12:00:00-03:00"` or `"2023-01-18T12:00:00.000Z"`. However, the milliseconds part is ignored.\n *  `user` the value must be an object that contains the `accountId` field.\n *  `group` the value must be an object that contains the group `name` or `groupId` field. Because group names can change, we recommend using `groupId`.\n\nA list of appropriate values must be provided if the field is of the `list` [collection type](https://developer.atlassian.com/platform/forge/manifest-reference/modules/jira-custom-field/#collection-types).',
    )


class MultipleCustomFieldValuesUpdateDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    updates: Optional[List[MultipleCustomFieldValuesUpdate]] = None


class NewUserDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    applicationKeys: Optional[List[str]] = Field(
        None, description='Deprecated, do not use.'
    )
    displayName: Optional[str] = Field(
        None,
        description='This property is no longer available. If the user has an Atlassian account, their display name is not changed. If the user does not have an Atlassian account, they are sent an email asking them set up an account.',
    )
    emailAddress: str = Field(..., description='The email address for the user.')
    key: Optional[str] = Field(
        None,
        description='This property is no longer available. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )
    name: Optional[str] = Field(
        None,
        description='This property is no longer available. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )
    password: Optional[str] = Field(
        None,
        description='This property is no longer available. If the user has an Atlassian account, their password is not changed. If the user does not have an Atlassian account, they are sent an email asking them set up an account.',
    )
    self: Optional[str] = Field(None, description='The URL of the user.')


class NotificationEvent(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the event.'
    )
    id: Optional[int_aliased] = Field(
        None,
        description='The ID of the event. The event can be a [Jira system event](https://confluence.atlassian.com/x/8YdKLg#Creatinganotificationscheme-eventsEvents) or a [custom event](https://confluence.atlassian.com/x/AIlKLg).',
    )
    name: Optional[str] = Field(None, description='The name of the event.')
    templateEvent: Optional[NotificationEvent] = Field(
        None,
        description='The template of the event. Only custom events configured by Jira administrators have template.',
    )


class NotificationSchemeAndProjectMappingJsonBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    notificationSchemeId: Optional[str] = None
    projectId: Optional[str] = None


class NotificationSchemeEventTypeId(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    id: str = Field(..., description='The ID of the notification scheme event.')


class NotificationSchemeId(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    id: str = Field(..., description='The ID of a notification scheme.')


class NotificationSchemeNotificationDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    notificationType: str = Field(
        ...,
        description='The notification type, e.g `CurrentAssignee`, `Group`, `EmailAddress`.',
    )
    parameter: Optional[str] = Field(
        None, description='The value corresponding to the specified notification type.'
    )


class OperationMessage(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    message: str = Field(
        ..., description='The human-readable message that describes the result.'
    )
    statusCode: int_aliased = Field(..., description='The status code of the response.')


class Position1(Enum):
    First = 'First'
    Last = 'Last'


class OrderOfCustomFieldOptions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    after: Optional[str] = Field(
        None,
        description="The ID of the custom field option or cascading option to place the moved options after. Required if `position` isn't provided.",
    )
    customFieldOptionIds: List[str] = Field(
        ...,
        description='A list of IDs of custom field options to move. The order of the custom field option IDs in the list is the order they are given after the move. The list must contain custom field options or cascading options, but not both.',
    )
    position: Optional[Position1] = Field(
        None,
        description="The position the custom field options should be moved to. Required if `after` isn't provided.",
    )


class OrderOfIssueTypes(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    after: Optional[str] = Field(
        None,
        description="The ID of the issue type to place the moved issue types after. Required if `position` isn't provided.",
    )
    issueTypeIds: List[str] = Field(
        ...,
        description='A list of the issue type IDs to move. The order of the issue type IDs in the list is the order they are given after the move.',
    )
    position: Optional[Position1] = Field(
        None,
        description="The position the issue types should be moved to. Required if `after` isn't provided.",
    )


class PageBeanContextForProjectAndIssueType(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[ContextForProjectAndIssueType]] = Field(
        None, description='The list of items.'
    )


class PageBeanContextualConfiguration(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[ContextualConfiguration]] = Field(
        None, description='The list of items.'
    )


class PageBeanCustomFieldContext(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[CustomFieldContext]] = Field(
        None, description='The list of items.'
    )


class PageBeanCustomFieldContextOption(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[CustomFieldContextOption]] = Field(
        None, description='The list of items.'
    )


class PageBeanCustomFieldContextProjectMapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[CustomFieldContextProjectMapping]] = Field(
        None, description='The list of items.'
    )


class PageBeanFieldConfigurationDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[FieldConfigurationDetails]] = Field(
        None, description='The list of items.'
    )


class PageBeanFieldConfigurationIssueTypeItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[FieldConfigurationIssueTypeItem]] = Field(
        None, description='The list of items.'
    )


class PageBeanFieldConfigurationItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[FieldConfigurationItem]] = Field(
        None, description='The list of items.'
    )


class PageBeanFieldConfigurationScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[FieldConfigurationScheme]] = Field(
        None, description='The list of items.'
    )


class PageBeanFieldConfigurationSchemeProjects(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[FieldConfigurationSchemeProjects]] = Field(
        None, description='The list of items.'
    )


class PageBeanGroupDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[GroupDetails]] = Field(None, description='The list of items.')


class PageBeanIssueTypeScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[IssueTypeScheme]] = Field(
        None, description='The list of items.'
    )


class PageBeanIssueTypeSchemeMapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[IssueTypeSchemeMapping]] = Field(
        None, description='The list of items.'
    )


class PageBeanIssueTypeSchemeProjects(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[IssueTypeSchemeProjects]] = Field(
        None, description='The list of items.'
    )


class PageBeanIssueTypeScreenScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[IssueTypeScreenScheme]] = Field(
        None, description='The list of items.'
    )


class PageBeanIssueTypeScreenSchemeItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[IssueTypeScreenSchemeItem]] = Field(
        None, description='The list of items.'
    )


class PageBeanIssueTypeScreenSchemesProjects(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[IssueTypeScreenSchemesProjects]] = Field(
        None, description='The list of items.'
    )


class PageBeanIssueTypeToContextMapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[IssueTypeToContextMapping]] = Field(
        None, description='The list of items.'
    )


class PageBeanJqlFunctionPrecomputationBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[JqlFunctionPrecomputationBean]] = Field(
        None, description='The list of items.'
    )


class PageBeanNotificationSchemeAndProjectMappingJsonBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[NotificationSchemeAndProjectMappingJsonBean]] = Field(
        None, description='The list of items.'
    )


class PageBeanString(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[str]] = Field(None, description='The list of items.')


class PermissionHolder(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional permission holder details in the response.',
    )
    parameter: Optional[str] = Field(
        None,
        description="As a group's name can change, use of `value` is recommended. The identifier associated withthe `type` value that defines the holder of the permission.",
    )
    type: str = Field(..., description='The type of permission holder.')
    value: Optional[str] = Field(
        None,
        description='The identifier associated with the `type` value that defines the holder of the permission.',
    )


class PermissionsKeysBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    permissions: List[str] = Field(..., description='A list of permission keys.')


class Priority(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    description: Optional[str] = Field(
        None, description='The description of the issue priority.'
    )
    iconUrl: Optional[str] = Field(
        None, description='The URL of the icon for the issue priority.'
    )
    id: Optional[str] = Field(None, description='The ID of the issue priority.')
    isDefault: Optional[bool] = Field(
        None, description='Whether this priority is the default.'
    )
    name: Optional[str] = Field(None, description='The name of the issue priority.')
    self: Optional[str] = Field(None, description='The URL of the issue priority.')
    statusColor: Optional[str] = Field(
        None, description='The color used to indicate the issue priority.'
    )


class PriorityId(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    id: str = Field(..., description='The ID of the issue priority.')


class Style(Enum):
    classic = 'classic'
    next_gen = 'next-gen'


class ProjectAvatars(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    custom: Optional[List[Avatar]] = Field(
        None, description='List of avatars added to Jira. These avatars may be deleted.'
    )
    system: Optional[List[Avatar]] = Field(
        None,
        description='List of avatars included with Jira. These avatars cannot be deleted.',
    )


class ProjectCategory(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the project category.'
    )
    id: Optional[str] = Field(None, description='The ID of the project category.')
    name: Optional[str] = Field(
        None,
        description='The name of the project category. Required on create, optional on update.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the project category.')


class AssigneeType3(Enum):
    PROJECT_DEFAULT = 'PROJECT_DEFAULT'
    COMPONENT_LEAD = 'COMPONENT_LEAD'
    PROJECT_LEAD = 'PROJECT_LEAD'
    UNASSIGNED = 'UNASSIGNED'


class ProjectEmailAddress(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    emailAddress: Optional[str] = Field(None, description='The email address.')
    emailAddressStatus: Optional[List[str]] = Field(
        None, description='When using a custom domain, the status of the email address.'
    )


class State(Enum):
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'
    COMING_SOON = 'COMING_SOON'


class ProjectFeature(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    feature: Optional[str] = Field(None, description='The key of the feature.')
    imageUri: Optional[str] = Field(
        None, description='URI for the image representing the feature.'
    )
    localisedDescription: Optional[str] = Field(
        None, description='Localized display description for the feature.'
    )
    localisedName: Optional[str] = Field(
        None, description='Localized display name for the feature.'
    )
    prerequisites: Optional[List[str]] = Field(
        None, description='List of keys of the features required to enable the feature.'
    )
    projectId: Optional[int_aliased] = Field(None, description='The ID of the project.')
    state: Optional[State] = Field(
        None,
        description='The state of the feature. When updating the state of a feature, only ENABLED and DISABLED are supported. Responses can contain all values',
    )
    toggleLocked: Optional[bool] = Field(
        None, description='Whether the state of the feature can be updated.'
    )


class ProjectFeatureState(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    state: Optional[State] = Field(None, description='The feature state.')


class ProjectId(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(..., description='The ID of the project.')


class ProjectIdentifierBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the project.')
    key: Optional[str] = Field(None, description='The key of the project.')


class ProjectIdentifiers(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: int_aliased = Field(..., description='The ID of the created project.')
    key: str = Field(..., description='The key of the created project.')
    self: AnyUrl = Field(..., description='The URL of the created project.')


class ProjectIds(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    projectIds: List[str] = Field(..., description='The IDs of projects.')


class ProjectInsight(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    lastIssueUpdateTime: Optional[datetime] = Field(
        None, description='The last issue update time.'
    )
    totalIssueCount: Optional[int_aliased] = Field(
        None, description='Total issue count.'
    )


class ProjectIssueTypeMapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeId: str = Field(..., description='The ID of the issue type.')
    projectId: str = Field(..., description='The ID of the project.')


class ProjectIssueTypeMappings(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mappings: List[ProjectIssueTypeMapping] = Field(
        ..., description='The project and issue type mappings.'
    )


class ProjectIssueTypes(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypes: Optional[List[str]] = Field(None, description='IDs of the issue types')
    project: Optional[ProjectId] = None


class ProjectIssueTypesHierarchyLevel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    entityId: Optional[UUID] = Field(
        None,
        description='The ID of the issue type hierarchy level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).',
    )
    issueTypes: Optional[List[IssueTypeInfo]] = Field(
        None, description='The list of issue types in the hierarchy level.'
    )
    level: Optional[int_aliased] = Field(
        None, description='The level of the issue type hierarchy level.'
    )
    name: Optional[str] = Field(
        None, description='The name of the issue type hierarchy level.'
    )


class ProjectLandingPageInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    attributes: Optional[Dict[str, str]] = None
    boardId: Optional[int_aliased] = None
    boardName: Optional[str] = None
    projectKey: Optional[str] = None
    projectType: Optional[str] = None
    queueCategory: Optional[str] = None
    queueId: Optional[int_aliased] = None
    queueName: Optional[str] = None
    simpleBoard: Optional[bool] = None
    simplified: Optional[bool] = None
    url: Optional[str] = None


class ProjectPermissions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    canEdit: Optional[bool] = Field(
        None, description='Whether the logged user can edit the project.'
    )


class ProjectRoleActorsUpdateBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    categorisedActors: Optional[Dict[str, List[str]]] = Field(
        None,
        description='The actors to add to the project role.\n\nAdd groups using:\n\n *  `atlassian-group-role-actor` and a list of group names.\n *  `atlassian-group-role-actor-id` and a list of group IDs.\n\nAs a group\'s name can change, use of `atlassian-group-role-actor-id` is recommended. For example, `"atlassian-group-role-actor-id":["eef79f81-0b89-4fca-a736-4be531a10869","77f6ab39-e755-4570-a6ae-2d7a8df0bcb8"]`.\n\nAdd users using `atlassian-user-role-actor` and a list of account IDs. For example, `"atlassian-user-role-actor":["12345678-9abc-def1-2345-6789abcdef12", "abcdef12-3456-789a-bcde-f123456789ab"]`.',
    )
    id: Optional[int_aliased] = Field(
        None,
        description='The ID of the project role. Use [Get all project roles](#api-rest-api-3-role-get) to get a list of project role IDs.',
    )


class ProjectRoleGroup(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    displayName: Optional[str] = Field(
        None, description='The display name of the group.'
    )
    groupId: Optional[str] = Field(None, description='The ID of the group.')
    name: Optional[str] = Field(
        None,
        description="The name of the group. As a group's name can change, use of `groupId` is recommended to identify the group.",
    )


class ProjectRoleUser(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountId: Optional[constr(max_length=128)] = Field(
        None,
        description='The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Returns *unknown* if the record is deleted and corrupted, for example, as the result of a server import.',
    )


class ProjectScopeBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    attributes: Optional[List[Attribute]] = Field(
        None,
        description="Defines the behavior of the option in the project.If notSelectable is set, the option cannot be set as the field's value. This is useful for archiving an option that has previously been selected but shouldn't be used anymore.If defaultValue is set, the option is selected by default.",
    )
    id: Optional[int_aliased] = Field(
        None, description="The ID of the project that the option's behavior applies to."
    )


class ProjectType(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    color: Optional[str] = Field(None, description='The color of the project type.')
    descriptionI18nKey: Optional[str] = Field(
        None, description="The key of the project type's description."
    )
    formattedKey: Optional[str] = Field(
        None, description='The formatted key of the project type.'
    )
    icon: Optional[str] = Field(None, description='The icon of the project type.')
    key: Optional[str] = Field(None, description='The key of the project type.')


class PropertyKey(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    key: Optional[str] = Field(None, description='The key of the property.')
    self: Optional[str] = Field(None, description='The URL of the property.')


class PropertyKeys(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    keys: Optional[List[PropertyKey]] = Field(None, description='Property key details.')


class PublishedWorkflowId(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    entityId: Optional[str] = Field(None, description='The entity ID of the workflow.')
    name: str = Field(..., description='The name of the workflow.')


class RegisteredWebhook(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    createdWebhookId: Optional[int_aliased] = Field(
        None, description='The ID of the webhook. Returned if the webhook is created.'
    )
    errors: Optional[List[str]] = Field(
        None, description='Error messages specifying why the webhook creation failed.'
    )


class RemoteIssueLinkIdentifies(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[int_aliased] = Field(
        None,
        description='The ID of the remote issue link, such as the ID of the item on the remote system.',
    )
    self: Optional[str] = Field(None, description='The URL of the remote issue link.')


class ReorderIssuePriorities(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    after: Optional[str] = Field(
        None,
        description="The ID of the priority. Required if `position` isn't provided.",
    )
    ids: List[str] = Field(
        ...,
        description='The list of issue IDs to be reordered. Cannot contain duplicates nor after ID.',
    )
    position: Optional[str] = Field(
        None,
        description="The position for issue priorities to be moved to. Required if `after` isn't provided.",
    )


class ReorderIssueResolutionsRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    after: Optional[str] = Field(
        None,
        description="The ID of the resolution. Required if `position` isn't provided.",
    )
    ids: List[str] = Field(
        ...,
        description='The list of resolution IDs to be reordered. Cannot contain duplicates nor after ID.',
    )
    position: Optional[str] = Field(
        None,
        description="The position for issue resolutions to be moved to. Required if `after` isn't provided.",
    )


class Resolution(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the issue resolution.'
    )
    id: Optional[str] = Field(None, description='The ID of the issue resolution.')
    name: Optional[str] = Field(None, description='The name of the issue resolution.')
    self: Optional[AnyUrl] = Field(None, description='The URL of the issue resolution.')


class ResolutionId(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    id: str = Field(..., description='The ID of the issue resolution.')


class ResolutionJsonBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    default: Optional[bool] = None
    description: Optional[str] = None
    iconUrl: Optional[str] = None
    id: Optional[str] = None
    name: Optional[str] = None
    self: Optional[str] = None


class RestrictedPermission(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    id: Optional[str] = Field(
        None,
        description='The ID of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions.',
    )
    key: Optional[str] = Field(
        None,
        description='The key of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions.',
    )


class RichText(BaseModel):
    empty: Optional[bool] = None
    emptyAdf: Optional[bool] = None
    finalised: Optional[bool] = None
    valueSet: Optional[bool] = None


class Type6(Enum):
    atlassian_group_role_actor = 'atlassian-group-role-actor'
    atlassian_user_role_actor = 'atlassian-user-role-actor'


class RoleActor(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    actorGroup: Optional[ProjectRoleGroup] = None
    actorUser: Optional[ProjectRoleUser] = None
    avatarUrl: Optional[AnyUrl] = Field(
        None, description='The avatar of the role actor.'
    )
    displayName: Optional[str] = Field(
        None,
        description="The display name of the role actor. For users, depending on the users privacy setting, this may return an alternative value for the user's name.",
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the role actor.')
    name: Optional[str] = Field(
        None,
        description='This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )
    type: Optional[Type6] = Field(None, description='The type of role actor.')


class RuleConfiguration(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    disabled: Optional[bool] = Field(
        False, description='EXPERIMENTAL: Whether the rule is disabled.'
    )
    tag: Optional[constr(max_length=255)] = Field(
        None,
        description='EXPERIMENTAL: A tag used to filter rules in [Get workflow transition rule configurations](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-workflow-transition-rules/#api-rest-api-3-workflow-rule-config-get).',
    )
    value: str = Field(
        ...,
        description='Configuration of the rule, as it is stored by the Connect app on the rule configuration page.',
    )


class SanitizedJqlQuery(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountId: Optional[constr(max_length=128)] = Field(
        None,
        description='The account ID of the user for whom sanitization was performed.',
    )
    errors: Optional[ErrorCollection] = Field(None, description='The list of errors.')
    initialQuery: Optional[str] = Field(None, description='The initial query.')
    sanitizedQuery: Optional[str] = Field(
        None, description='The sanitized query, if there were no errors.'
    )


class Type7(Enum):
    PROJECT = 'PROJECT'
    TEMPLATE = 'TEMPLATE'


class ScreenDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the screen. The maximum length is 255 characters.',
    )
    name: str = Field(
        ...,
        description='The name of the screen. The name must be unique. The maximum length is 255 characters.',
    )


class ScreenSchemeId(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: int_aliased = Field(..., description='The ID of the screen scheme.')


class ScreenTypes(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    create: Optional[int_aliased] = Field(
        None, description='The ID of the create screen.'
    )
    default: Optional[int_aliased] = Field(
        None,
        description='The ID of the default screen. Required when creating a screen scheme.',
    )
    edit: Optional[int_aliased] = Field(None, description='The ID of the edit screen.')
    view: Optional[int_aliased] = Field(None, description='The ID of the view screen.')


class ScreenableField(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description='The ID of the screen tab field.')
    name: Optional[str] = Field(
        None,
        description='The name of the screen tab field. Required on create and update. The maximum length is 255 characters.',
    )


class ScreenableTab(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the screen tab.')
    name: str = Field(
        ...,
        description='The name of the screen tab. The maximum length is 255 characters.',
    )


class SearchAutoCompleteFilter(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    includeCollapsedFields: Optional[bool] = Field(
        False,
        description='Include collapsed fields for fields that have non-unique names.',
    )
    projectIds: Optional[List[int_aliased]] = Field(
        None,
        description='List of project IDs used to filter the visible field details returned.',
    )


class ValidateQuery(Enum):
    strict = 'strict'
    warn = 'warn'
    none = 'none'
    true = 'true'
    false = 'false'


class SearchRequestBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expand: Optional[List[str]] = Field(
        None,
        description="Use [expand](em>#expansion) to include additional information about issues in the response. Note that, unlike the majority of instances where `expand` is specified, `expand` is defined as a list of values. The expand options are:\n\n *  `renderedFields` Returns field values rendered in HTML format.\n *  `names` Returns the display name of each field.\n *  `schema` Returns the schema describing a field type.\n *  `transitions` Returns all possible transitions for the issue.\n *  `operations` Returns all possible operations for the issue.\n *  `editmeta` Returns information about how each field can be edited.\n *  `changelog` Returns a list of recent updates to an issue, sorted by date, starting from the most recent.\n *  `versionedRepresentations` Instead of `fields`, returns `versionedRepresentations` a JSON array containing each version of a field's value, with the highest numbered item representing the most recent version.",
    )
    fields: Optional[List[str]] = Field(
        None,
        description='A list of fields to return for each issue, use it to retrieve a subset of fields. This parameter accepts a comma-separated list. Expand options include:\n\n *  `*all` Returns all fields.\n *  `*navigable` Returns navigable fields.\n *  Any issue field, prefixed with a minus to exclude.\n\nThe default is `*navigable`.\n\nExamples:\n\n *  `summary,comment` Returns the summary and comments fields only.\n *  `-description` Returns all navigable (default) fields except description.\n *  `*all,-comment` Returns all fields except comments.\n\nMultiple `fields` parameters can be included in a request.\n\nNote: All navigable fields are returned by default. This differs from [GET issue](#api-rest-api-3-issue-issueIdOrKey-get) where the default is all fields.',
    )
    fieldsByKeys: Optional[bool] = Field(
        None,
        description='Reference fields by their key (rather than ID). The default is `false`.',
    )
    jql: Optional[str] = Field(
        None,
        description='A [JQL](https://confluence.atlassian.com/x/egORLQ) expression.',
    )
    maxResults: Optional[int_aliased] = Field(
        50, description='The maximum number of items to return per page.'
    )
    properties: Optional[List[str]] = Field(
        None,
        description='A list of up to 5 issue properties to include in the results. This parameter accepts a comma-separated list.',
    )
    startAt: Optional[int_aliased] = Field(
        None,
        description='The index of the first item to return in the page of results (page offset). The base index is `0`.',
    )
    validateQuery: Optional[ValidateQuery] = Field(
        None,
        description='Determines how to validate the JQL query and treat the validation results. Supported values:\n\n *  `strict` Returns a 400 response code if any errors are found, along with a list of all errors (and warnings).\n *  `warn` Returns all errors as warnings.\n *  `none` No validation is performed.\n *  `true` *Deprecated* A legacy synonym for `strict`.\n *  `false` *Deprecated* A legacy synonym for `warn`.\n\nThe default is `strict`.\n\nNote: If the JQL is not correctly formed a 400 response code is returned, regardless of the `validateQuery` value.',
    )


class SecurityLevel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the issue level security item.'
    )
    id: Optional[str] = Field(
        None, description='The ID of the issue level security item.'
    )
    isDefault: Optional[bool] = Field(
        None, description='Whether the issue level security item is the default.'
    )
    issueSecuritySchemeId: Optional[str] = Field(
        None, description='The ID of the issue level security scheme.'
    )
    name: Optional[str] = Field(
        None, description='The name of the issue level security item.'
    )
    self: Optional[str] = Field(
        None, description='The URL of the issue level security item.'
    )


class SecurityScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    defaultSecurityLevelId: Optional[int_aliased] = Field(
        None, description='The ID of the default security level.'
    )
    description: Optional[str] = Field(
        None, description='The description of the issue security scheme.'
    )
    id: Optional[int_aliased] = Field(
        None, description='The ID of the issue security scheme.'
    )
    levels: Optional[List[SecurityLevel]] = None
    name: Optional[str] = Field(
        None, description='The name of the issue security scheme.'
    )
    self: Optional[str] = Field(
        None, description='The URL of the issue security scheme.'
    )


class SecuritySchemes(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueSecuritySchemes: Optional[List[SecurityScheme]] = Field(
        None, description='List of security schemes.'
    )


class ServerInformation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    baseUrl: Optional[str] = Field(
        None, description='The base URL of the Jira instance.'
    )
    buildDate: Optional[datetime] = Field(
        None, description='The timestamp when the Jira version was built.'
    )
    buildNumber: Optional[int_aliased] = Field(
        None, description='The build number of the Jira version.'
    )
    deploymentType: Optional[str] = Field(
        None,
        description='The type of server deployment. This is always returned as *Cloud*.',
    )
    healthChecks: Optional[List[HealthCheckResult]] = Field(
        None,
        description='Jira instance health check results. Deprecated and no longer returned.',
    )
    scmInfo: Optional[str] = Field(
        None, description='The unique identifier of the Jira version.'
    )
    serverTime: Optional[datetime] = Field(
        None, description='The time in Jira when this request was responded to.'
    )
    serverTitle: Optional[str] = Field(
        None, description='The name of the Jira instance.'
    )
    version: Optional[str] = Field(None, description='The version of Jira.')
    versionNumbers: Optional[List[int_aliased]] = Field(
        None,
        description='The major, minor, and revision version numbers of the Jira version.',
    )


class ServiceManagementNavigationInfo(BaseModel):
    queueCategory: Optional[str] = None
    queueId: Optional[int_aliased] = None
    queueName: Optional[str] = None


class SetDefaultPriorityRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(
        ...,
        description='The ID of the new default issue priority. Must be an existing ID or null. Setting this to null erases the default priority setting.',
    )


class SetDefaultResolutionRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(
        ...,
        description='The ID of the new default issue resolution. Must be an existing ID or null. Setting this to null erases the default resolution setting.',
    )


class Type8(Enum):
    user = 'user'
    group = 'group'
    project = 'project'
    projectRole = 'projectRole'
    global_ = 'global'
    loggedin = 'loggedin'
    authenticated = 'authenticated'
    project_unknown = 'project-unknown'


class Type9(Enum):
    user = 'user'
    project = 'project'
    group = 'group'
    projectRole = 'projectRole'
    global_ = 'global'
    authenticated = 'authenticated'


class SharePermissionInputBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountId: Optional[str] = Field(
        None,
        description='The user account ID that the filter is shared with. For a request, specify the `accountId` property for the user.',
    )
    groupId: Optional[str] = Field(
        None,
        description='The ID of the group, which uniquely identifies the group across all Atlassian products.For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*. Cannot be provided with `groupname`.',
    )
    groupname: Optional[str] = Field(
        None,
        description='The name of the group to share the filter with. Set `type` to `group`. Please note that the name of a group is mutable, to reliably identify a group use `groupId`.',
    )
    projectId: Optional[str] = Field(
        None,
        description='The ID of the project to share the filter with. Set `type` to `project`.',
    )
    projectRoleId: Optional[str] = Field(
        None,
        description='The ID of the project role to share the filter with. Set `type` to `projectRole` and the `projectId` for the project that the role is in.',
    )
    rights: Optional[int_aliased] = Field(
        None, description='The rights for the share permission.'
    )
    type: Type9 = Field(
        ...,
        description='The type of the share permission.Specify the type as follows:\n\n *  `user` Share with a user.\n *  `group` Share with a group. Specify `groupname` as well.\n *  `project` Share with a project. Specify `projectId` as well.\n *  `projectRole` Share with a project role in a project. Specify `projectId` and `projectRoleId` as well.\n *  `global` Share globally, including anonymous users. If set, this type overrides all existing share permissions and must be deleted before any non-global share permissions is set.\n *  `authenticated` Share with all logged-in users. This shows as `loggedin` in the response. If set, this type overrides all existing share permissions and must be deleted before any non-global share permissions is set.',
    )


class SimpleApplicationPropertyBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description='The ID of the application property.')
    value: Optional[str] = Field(None, description='The new value.')


class SimpleErrorCollection(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    errorMessages: Optional[List[str]] = Field(
        None,
        description='The list of error messages produced by this operation. For example, "input parameter \'key\' must be provided"',
    )
    errors: Optional[Dict[str, str]] = Field(
        None,
        description='The list of errors by parameter returned by the operation. For example,"projectKey": "Project keys must start with an uppercase letter, followed by one or more uppercase alphanumeric characters."',
    )
    httpStatusCode: Optional[int_aliased] = None


class SimpleLink(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    href: Optional[str] = None
    iconClass: Optional[str] = None
    id: Optional[str] = None
    label: Optional[str] = None
    styleClass: Optional[str] = None
    title: Optional[str] = None
    weight: Optional[int_aliased] = None


class SimpleListWrapperGroupName(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    callback: Optional[ListWrapperCallbackGroupName] = None
    items: Optional[List[GroupName]] = None
    max_results: Optional[int_aliased] = Field(None, alias='max-results')
    pagingCallback: Optional[ListWrapperCallbackGroupName] = None
    size: Optional[int_aliased] = None


class SimplifiedHierarchyLevel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aboveLevelId: Optional[int_aliased] = Field(
        None,
        description='The ID of the level above this one in the hierarchy. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).',
    )
    belowLevelId: Optional[int_aliased] = Field(
        None,
        description='The ID of the level below this one in the hierarchy. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).',
    )
    externalUuid: Optional[UUID] = Field(
        None,
        description='The external UUID of the hierarchy level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).',
    )
    hierarchyLevelNumber: Optional[int_aliased] = None
    id: Optional[int_aliased] = Field(
        None,
        description='The ID of the hierarchy level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).',
    )
    issueTypeIds: Optional[List[int_aliased]] = Field(
        None, description='The issue types available in this hierarchy level.'
    )
    level: Optional[int_aliased] = Field(
        None, description='The level of this item in the hierarchy.'
    )
    name: Optional[str] = Field(None, description='The name of this hierarchy level.')
    projectConfigurationId: Optional[int_aliased] = Field(
        None,
        description='The ID of the project configuration. This property is deprecated, see [Change oticen: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).',
    )


class SoftwareNavigationInfo(BaseModel):
    boardId: Optional[int_aliased] = None
    boardName: Optional[str] = None
    simpleBoard: Optional[bool] = None
    totalBoardsInProject: Optional[int_aliased] = None


class Status(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    icon: Optional[Icon] = Field(
        None,
        description='Details of the icon representing the status. If not provided, no status icon displays in Jira.',
    )
    resolved: Optional[bool] = Field(
        None,
        description='Whether the item is resolved. If set to "true", the link to the issue is displayed in a strikethrough font, otherwise the link displays in normal font.',
    )


class StatusCategory1(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    colorName: Optional[str] = Field(
        None, description='The name of the color used to represent the status category.'
    )
    id: Optional[int_aliased] = Field(
        None, description='The ID of the status category.'
    )
    key: Optional[str] = Field(None, description='The key of the status category.')
    name: Optional[str] = Field(None, description='The name of the status category.')
    self: Optional[str] = Field(None, description='The URL of the status category.')


class StatusCategory2(Enum):
    TODO = 'TODO'
    IN_PROGRESS = 'IN_PROGRESS'
    DONE = 'DONE'


class StatusCreate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the status.'
    )
    name: constr(max_length=255) = Field(..., description='The name of the status.')
    statusCategory: StatusCategory2 = Field(
        ..., description='The category of the status.'
    )


class StatusDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    description: Optional[str] = Field(
        None, description='The description of the status.'
    )
    iconUrl: Optional[str] = Field(
        None, description='The URL of the icon used to represent the status.'
    )
    id: Optional[str] = Field(None, description='The ID of the status.')
    name: Optional[str] = Field(None, description='The name of the status.')
    self: Optional[str] = Field(None, description='The URL of the status.')
    statusCategory: Optional[StatusCategory1] = Field(
        None, description='The category assigned to the status.'
    )


class StatusMapping(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueTypeId: str = Field(..., description='The ID of the issue type.')
    newStatusId: str = Field(..., description='The ID of the new status.')
    statusId: str = Field(..., description='The ID of the status.')


class Type10(Enum):
    PROJECT = 'PROJECT'
    GLOBAL = 'GLOBAL'


class StatusScope(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    project: Optional[ProjectId] = None
    type: Type10 = Field(
        ...,
        description='The scope of the status. `GLOBAL` for company-managed projects and `PROJECT` for team-managed projects.',
    )


class StatusUpdate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the status.'
    )
    id: str = Field(..., description='The ID of the status.')
    name: str = Field(..., description='The name of the status.')
    statusCategory: StatusCategory2 = Field(
        ..., description='The category of the status.'
    )


class StatusUpdateRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    statuses: Optional[List[StatusUpdate]] = Field(
        None, description='The list of statuses that will be updated.'
    )


class StringList(BaseModel):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class SuggestedIssue(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the issue.')
    img: Optional[str] = Field(None, description="The URL of the issue type's avatar.")
    key: Optional[str] = Field(None, description='The key of the issue.')
    keyHtml: Optional[str] = Field(
        None, description='The key of the issue in HTML format.'
    )
    summary: Optional[str] = Field(
        None,
        description='The phrase containing the query string in HTML format, with the string highlighted with HTML bold tags.',
    )
    summaryText: Optional[str] = Field(
        None, description='The phrase containing the query string, as plain text.'
    )


class SystemAvatars(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    system: Optional[List[Avatar]] = Field(
        None, description='A list of avatar details.'
    )


class Status1(Enum):
    ENQUEUED = 'ENQUEUED'
    RUNNING = 'RUNNING'
    COMPLETE = 'COMPLETE'
    FAILED = 'FAILED'
    CANCEL_REQUESTED = 'CANCEL_REQUESTED'
    CANCELLED = 'CANCELLED'
    DEAD = 'DEAD'


class TaskProgressBeanObject(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(None, description='The description of the task.')
    elapsedRuntime: int_aliased = Field(
        ..., description='The execution time of the task, in milliseconds.'
    )
    finished: Optional[int_aliased] = Field(
        None, description='A timestamp recording when the task was finished.'
    )
    id: str = Field(..., description='The ID of the task.')
    lastUpdate: int_aliased = Field(
        ...,
        description='A timestamp recording when the task progress was last updated.',
    )
    message: Optional[str] = Field(
        None, description='Information about the progress of the task.'
    )
    progress: int_aliased = Field(
        ..., description='The progress of the task, as a percentage complete.'
    )
    result: Optional[Any] = Field(None, description='The result of the task execution.')
    self: AnyUrl = Field(..., description='The URL of the task.')
    started: Optional[int_aliased] = Field(
        None, description='A timestamp recording when the task was started.'
    )
    status: Status1 = Field(..., description='The status of the task.')
    submitted: int_aliased = Field(
        ..., description='A timestamp recording when the task was submitted.'
    )
    submittedBy: int_aliased = Field(
        ..., description='The ID of the user who submitted the task.'
    )


class DefaultUnit(Enum):
    minute = 'minute'
    hour = 'hour'
    day = 'day'
    week = 'week'


class TimeFormat(Enum):
    pretty = 'pretty'
    days = 'days'
    hours = 'hours'


class TimeTrackingConfiguration(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    defaultUnit: DefaultUnit = Field(
        ..., description='The default unit of time applied to logged time.'
    )
    timeFormat: TimeFormat = Field(
        ..., description="The format that will appear on an issue's *Time Spent* field."
    )
    workingDaysPerWeek: float = Field(
        ..., description='The number of days in a working week.'
    )
    workingHoursPerDay: float = Field(
        ..., description='The number of hours in a working day.'
    )


class TimeTrackingDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    originalEstimate: Optional[str] = Field(
        None,
        description='The original estimate of time needed for this issue in readable format.',
    )
    originalEstimateSeconds: Optional[int_aliased] = Field(
        None,
        description='The original estimate of time needed for this issue in seconds.',
    )
    remainingEstimate: Optional[str] = Field(
        None,
        description='The remaining estimate of time needed for this issue in readable format.',
    )
    remainingEstimateSeconds: Optional[int_aliased] = Field(
        None,
        description='The remaining estimate of time needed for this issue in seconds.',
    )
    timeSpent: Optional[str] = Field(
        None, description='Time worked on this issue in readable format.'
    )
    timeSpentSeconds: Optional[int_aliased] = Field(
        None, description='Time worked on this issue in seconds.'
    )


class TimeTrackingProvider(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    key: str = Field(
        ..., description='The key for the time tracking provider. For example, *JIRA*.'
    )
    name: Optional[str] = Field(
        None,
        description='The name of the time tracking provider. For example, *JIRA provided time tracking*.',
    )
    url: Optional[str] = Field(
        None,
        description='The URL of the configuration page for the time tracking provider app. For example, */example/config/url*. This property is only returned if the `adminPageKey` property is set in the module descriptor of the time tracking provider app.',
    )


class Type11(Enum):
    global_ = 'global'
    initial = 'initial'
    directed = 'directed'


class TransitionScreenDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(..., description='The ID of the screen.')
    name: Optional[str] = Field(None, description='The name of the screen.')


class UiModificationContextDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(
        None, description='The ID of the UI modification context.'
    )
    isAvailable: Optional[bool] = Field(
        None,
        description='Whether a context is available. For example, when a project is deleted the context becomes unavailable.',
    )
    issueTypeId: str = Field(..., description='The issue type ID of the context.')
    projectId: str = Field(..., description='The project ID of the context.')
    viewType: str = Field(
        ...,
        description='The view type of the context. Only `GIC` (Global Issue Create) is supported.',
    )


class UiModificationDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    contexts: Optional[List[UiModificationContextDetails]] = Field(
        None,
        description='List of contexts of the UI modification. The maximum number of contexts is 1000.',
    )
    data: Optional[str] = Field(
        None,
        description='The data of the UI modification. The maximum size of the data is 50000 characters.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the UI modification. The maximum length is 255 characters.',
    )
    id: str = Field(..., description='The ID of the UI modification.')
    name: str = Field(
        ...,
        description='The name of the UI modification. The maximum length is 255 characters.',
    )
    self: str = Field(..., description='The URL of the UI modification.')


class UiModificationIdentifiers(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(..., description='The ID of the UI modification.')
    self: str = Field(..., description='The URL of the UI modification.')


class UnrestrictedUserEmail(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    accountId: Optional[str] = Field(None, description='The accountId of the user')
    email: Optional[str] = Field(None, description='The email of the user')


class UpdateCustomFieldDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the custom field. The maximum length is 40000 characters.',
    )
    name: Optional[str] = Field(
        None,
        description="The name of the custom field. It doesn't have to be unique. The maximum length is 255 characters.",
    )
    searcherKey: Optional[SearcherKey] = Field(
        None,
        description='The searcher that defines the way the field is searched in Jira. It can be set to `null`, otherwise you must specify the valid searcher for the field type, as listed below (abbreviated values shown):\n\n *  `cascadingselect`: `cascadingselectsearcher`\n *  `datepicker`: `daterange`\n *  `datetime`: `datetimerange`\n *  `float`: `exactnumber` or `numberrange`\n *  `grouppicker`: `grouppickersearcher`\n *  `importid`: `exactnumber` or `numberrange`\n *  `labels`: `labelsearcher`\n *  `multicheckboxes`: `multiselectsearcher`\n *  `multigrouppicker`: `multiselectsearcher`\n *  `multiselect`: `multiselectsearcher`\n *  `multiuserpicker`: `userpickergroupsearcher`\n *  `multiversion`: `versionsearcher`\n *  `project`: `projectsearcher`\n *  `radiobuttons`: `multiselectsearcher`\n *  `readonlyfield`: `textsearcher`\n *  `select`: `multiselectsearcher`\n *  `textarea`: `textsearcher`\n *  `textfield`: `textsearcher`\n *  `url`: `exacttextsearcher`\n *  `userpicker`: `userpickergroupsearcher`\n *  `version`: `versionsearcher`',
    )


class UpdateDefaultScreenScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    screenSchemeId: str = Field(..., description='The ID of the screen scheme.')


class UpdateFieldConfigurationSchemeDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[constr(max_length=1024)] = Field(
        None, description='The description of the field configuration scheme.'
    )
    name: constr(max_length=255) = Field(
        ...,
        description='The name of the field configuration scheme. The name must be unique.',
    )


class UpdateNotificationSchemeDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    description: Optional[constr(max_length=4000)] = Field(
        None, description='The description of the notification scheme.'
    )
    name: Optional[constr(max_length=255)] = Field(
        None, description='The name of the notification scheme. Must be unique.'
    )


class UpdatePriorityDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    description: Optional[constr(max_length=255)] = Field(
        None, description='The description of the priority.'
    )
    iconUrl: Optional[IconUrl] = Field(
        None,
        description='The URL of an icon for the priority. Accepted protocols are HTTP and HTTPS. Built in icons can also be used.',
    )
    name: Optional[constr(max_length=60)] = Field(
        None, description='The name of the priority. Must be unique.'
    )
    statusColor: Optional[str] = Field(
        None,
        description='The status color of the priority in 3-digit or 6-digit hexadecimal format.',
    )


class AssigneeType4(Enum):
    PROJECT_LEAD = 'PROJECT_LEAD'
    UNASSIGNED = 'UNASSIGNED'


class UpdateProjectDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    assigneeType: Optional[AssigneeType4] = Field(
        None, description='The default assignee when creating issues for this project.'
    )
    avatarId: Optional[int_aliased] = Field(
        None, description="An integer value for the project's avatar."
    )
    categoryId: Optional[int_aliased] = Field(
        None,
        description="The ID of the project's category. A complete list of category IDs is found using the [Get all project categories](#api-rest-api-3-projectCategory-get) operation. To remove the project category from the project, set the value to `-1.`",
    )
    description: Optional[str] = Field(
        None, description='A brief description of the project.'
    )
    issueSecurityScheme: Optional[int_aliased] = Field(
        None,
        description='The ID of the issue security scheme for the project, which enables you to control who can and cannot view issues. Use the [Get issue security schemes](#api-rest-api-3-issuesecurityschemes-get) resource to get all issue security scheme IDs.',
    )
    key: Optional[str] = Field(
        None,
        description='Project keys must be unique and start with an uppercase letter followed by one or more uppercase alphanumeric characters. The maximum length is 10 characters.',
    )
    lead: Optional[str] = Field(
        None,
        description='This parameter is deprecated because of privacy changes. Use `leadAccountId` instead. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details. The user name of the project lead. Cannot be provided with `leadAccountId`.',
    )
    leadAccountId: Optional[constr(max_length=128)] = Field(
        None,
        description='The account ID of the project lead. Cannot be provided with `lead`.',
    )
    name: Optional[str] = Field(None, description='The name of the project.')
    notificationScheme: Optional[int_aliased] = Field(
        None,
        description='The ID of the notification scheme for the project. Use the [Get notification schemes](#api-rest-api-3-notificationscheme-get) resource to get a list of notification scheme IDs.',
    )
    permissionScheme: Optional[int_aliased] = Field(
        None,
        description='The ID of the permission scheme for the project. Use the [Get all permission schemes](#api-rest-api-3-permissionscheme-get) resource to see a list of all permission scheme IDs.',
    )
    url: Optional[str] = Field(
        None,
        description='A link to information about this project, such as project documentation',
    )


class UpdateResolutionDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    description: Optional[constr(max_length=255)] = Field(
        None, description='The description of the resolution.'
    )
    name: constr(max_length=60) = Field(
        ..., description='The name of the resolution. Must be unique.'
    )


class UpdateScreenDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the screen. The maximum length is 255 characters.',
    )
    name: Optional[str] = Field(
        None,
        description='The name of the screen. The name must be unique. The maximum length is 255 characters.',
    )


class UpdateScreenTypes(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    create: Optional[str] = Field(
        None,
        description='The ID of the create screen. To remove the screen association, pass a null.',
    )
    default: Optional[str] = Field(
        None,
        description='The ID of the default screen. When specified, must include a screen ID as a default screen is required.',
    )
    edit: Optional[str] = Field(
        None,
        description='The ID of the edit screen. To remove the screen association, pass a null.',
    )
    view: Optional[str] = Field(
        None,
        description='The ID of the view screen. To remove the screen association, pass a null.',
    )


class UpdateUiModificationDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    contexts: Optional[List[UiModificationContextDetails]] = Field(
        None,
        description='List of contexts of the UI modification. The maximum number of contexts is 1000. If provided, replaces all existing contexts.',
    )
    data: Optional[str] = Field(
        None,
        description='The data of the UI modification. The maximum size of the data is 50000 characters.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the UI modification. The maximum length is 255 characters.',
    )
    name: Optional[str] = Field(
        None,
        description='The name of the UI modification. The maximum length is 255 characters.',
    )


class UpdateUserToGroupBean(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    accountId: Optional[constr(max_length=128)] = Field(
        None,
        description='The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.',
    )
    name: Optional[str] = Field(
        None,
        description='This property is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )


class UpdatedProjectCategory(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The name of the project category.'
    )
    id: Optional[str] = Field(None, description='The ID of the project category.')
    name: Optional[str] = Field(
        None, description='The description of the project category.'
    )
    self: Optional[str] = Field(None, description='The URL of the project category.')


class AccountType(Enum):
    atlassian = 'atlassian'
    app = 'app'
    customer = 'customer'
    unknown = 'unknown'


class UserBeanAvatarUrls(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field_16x16: Optional[AnyUrl] = Field(
        None, alias='16x16', description="The URL of the user's 16x16 pixel avatar."
    )
    field_24x24: Optional[AnyUrl] = Field(
        None, alias='24x24', description="The URL of the user's 24x24 pixel avatar."
    )
    field_32x32: Optional[AnyUrl] = Field(
        None, alias='32x32', description="The URL of the user's 32x32 pixel avatar."
    )
    field_48x48: Optional[AnyUrl] = Field(
        None, alias='48x48', description="The URL of the user's 48x48 pixel avatar."
    )


class UserContextVariable(BaseModel):
    accountId: str = Field(..., description='The account ID of the user.')
    type: str = Field(..., description='Type of custom context variable.')


class UserDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountId: Optional[constr(max_length=128)] = Field(
        None,
        description='The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.',
    )
    accountType: Optional[str] = Field(
        None,
        description="The type of account represented by this user. This will be one of 'atlassian' (normal users), 'app' (application user) or 'customer' (Jira Service Desk customer user)",
    )
    active: Optional[bool] = Field(None, description='Whether the user is active.')
    avatarUrls: Optional[AvatarUrlsBean] = Field(
        None, description='The avatars of the user.'
    )
    displayName: Optional[str] = Field(
        None,
        description='The display name of the user. Depending on the users privacy settings, this may return an alternative value.',
    )
    emailAddress: Optional[str] = Field(
        None,
        description='The email address of the user. Depending on the users privacy settings, this may be returned as null.',
    )
    key: Optional[str] = Field(
        None,
        description='This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )
    name: Optional[str] = Field(
        None,
        description='This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )
    self: Optional[str] = Field(None, description='The URL of the user.')
    timeZone: Optional[str] = Field(
        None,
        description="The time zone specified in the user's profile. Depending on the users privacy settings, this may be returned as null.",
    )


class UserFilter(BaseModel):
    enabled: bool = Field(..., description='Whether the filter is enabled.')
    groups: Optional[List[str]] = Field(
        None,
        description='User groups autocomplete suggestion users must belong to. If not provided, the default values are used. A maximum of 10 groups can be provided.',
    )
    roleIds: Optional[List[int_aliased]] = Field(
        None,
        description='Roles that autocomplete suggestion users must belong to. If not provided, the default values are used. A maximum of 10 roles can be provided.',
    )


class UserKey(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountId: Optional[constr(max_length=128)] = Field(
        None,
        description='The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Returns *unknown* if the record is deleted and corrupted, for example, as the result of a server import.',
    )
    key: Optional[str] = Field(
        None,
        description='This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )


class UserMigrationBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountId: Optional[str] = None
    key: Optional[str] = None
    username: Optional[str] = None


class Type12(Enum):
    GLOBAL = 'GLOBAL'
    PROJECT = 'PROJECT'


class UserPermission(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    deprecatedKey: Optional[bool] = Field(
        None,
        description='Indicate whether the permission key is deprecated. Note that deprecated keys cannot be used in the `permissions parameter of Get my permissions. Deprecated keys are not returned by Get all permissions.`',
    )
    description: Optional[str] = Field(
        None, description='The description of the permission.'
    )
    havePermission: Optional[bool] = Field(
        None,
        description='Whether the permission is available to the user in the queried context.',
    )
    id: Optional[str] = Field(
        None,
        description='The ID of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions.',
    )
    key: Optional[str] = Field(
        None,
        description='The key of the permission. Either `id` or `key` must be specified. Use [Get all permissions](#api-rest-api-3-permissions-get) to get the list of permissions.',
    )
    name: Optional[str] = Field(None, description='The name of the permission.')
    type: Optional[Type12] = Field(None, description='The type of the permission.')


class UserPickerUser(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountId: Optional[str] = Field(
        None,
        description='The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.',
    )
    avatarUrl: Optional[AnyUrl] = Field(None, description='The avatar URL of the user.')
    displayName: Optional[str] = Field(
        None,
        description='The display name of the user. Depending on the users privacy setting, this may be returned as null.',
    )
    html: Optional[str] = Field(
        None,
        description='The display name, email address, and key of the user with the matched query string highlighted with the HTML bold tag.',
    )
    key: Optional[str] = Field(
        None,
        description='This property is no longer available. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )
    name: Optional[str] = Field(
        None,
        description='This property is no longer available . See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )


class ValueOperand(BaseModel):
    encodedValue: Optional[str] = Field(
        None, description='Encoded value, which can be used directly in a JQL query.'
    )
    value: str = Field(..., description='The operand value.')


class VersionIssuesStatus(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    done: Optional[int_aliased] = Field(
        None, description='Count of issues with status *done*.'
    )
    inProgress: Optional[int_aliased] = Field(
        None, description='Count of issues with status *in progress*.'
    )
    toDo: Optional[int_aliased] = Field(
        None, description='Count of issues with status *to do*.'
    )
    unmapped: Optional[int_aliased] = Field(
        None,
        description='Count of issues with a status other than *to do*, *in progress*, and *done*.',
    )


class Position3(Enum):
    Earlier = 'Earlier'
    Later = 'Later'
    First = 'First'
    Last = 'Last'


class VersionMoveBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    after: Optional[AnyUrl] = Field(
        None,
        description='The URL (self link) of the version after which to place the moved version. Cannot be used with `position`.',
    )
    position: Optional[Position3] = Field(
        None,
        description='An absolute position in which to place the moved version. Cannot be used with `after`.',
    )


class VersionUnresolvedIssuesCount(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issuesCount: Optional[int_aliased] = Field(None, description='Count of issues.')
    issuesUnresolvedCount: Optional[int_aliased] = Field(
        None, description='Count of unresolved issues.'
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of these count details.')


class VersionUsageInCustomField(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    customFieldId: Optional[int_aliased] = Field(
        None, description='The ID of the custom field.'
    )
    fieldName: Optional[str] = Field(None, description='The name of the custom field.')
    issueCountWithVersionInCustomField: Optional[int_aliased] = Field(
        None,
        description='Count of the issues where the custom field contains the version.',
    )


class Type13(Enum):
    group = 'group'
    role = 'role'


class VisibilityModel(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    identifier: Optional[str] = Field(
        None,
        description='The ID of the group or the name of the role that visibility of this item is restricted to.',
    )
    type: Optional[Type13] = Field(
        None,
        description='Whether visibility of this item is restricted to a group or role.',
    )
    value: Optional[str] = Field(
        None,
        description='The name of the group or role that visibility of this item is restricted to. Please note that the name of a group is mutable, to reliably identify a group use `identifier`.',
    )


class WarningCollection(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    warnings: Optional[List[str]] = None


class Watchers(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isWatching: Optional[bool] = Field(
        None, description='Whether the calling user is watching this issue.'
    )
    self: Optional[str] = Field(
        None, description='The URL of these issue watcher details.'
    )
    watchCount: Optional[int_aliased] = Field(
        None, description='The number of users watching this issue.'
    )
    watchers: Optional[List[UserDetails]] = Field(
        None, description='Details of the users watching this issue.'
    )


class Event(Enum):
    jira_issue_created = 'jira:issue_created'
    jira_issue_updated = 'jira:issue_updated'
    jira_issue_deleted = 'jira:issue_deleted'
    comment_created = 'comment_created'
    comment_updated = 'comment_updated'
    comment_deleted = 'comment_deleted'
    issue_property_set = 'issue_property_set'
    issue_property_deleted = 'issue_property_deleted'


class Webhook(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    events: List[Event] = Field(
        ..., description='The Jira events that trigger the webhook.'
    )
    expirationDate: Optional[int_aliased] = Field(
        None,
        description='The date after which the webhook is no longer sent. Use [Extend webhook life](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-webhooks/#api-rest-api-3-webhook-refresh-put) to extend the date.',
    )
    fieldIdsFilter: Optional[List[str]] = Field(
        None,
        description='A list of field IDs. When the issue changelog contains any of the fields, the webhook `jira:issue_updated` is sent. If this parameter is not present, the app is notified about all field updates.',
    )
    id: int_aliased = Field(..., description='The ID of the webhook.')
    issuePropertyKeysFilter: Optional[List[str]] = Field(
        None,
        description='A list of issue property keys. A change of those issue properties triggers the `issue_property_set` or `issue_property_deleted` webhooks. If this parameter is not present, the app is notified about all issue property updates.',
    )
    jqlFilter: str = Field(
        ...,
        description='The JQL filter that specifies which issues the webhook is sent for.',
    )


class WebhookDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    events: List[Event] = Field(
        ..., description='The Jira events that trigger the webhook.'
    )
    fieldIdsFilter: Optional[List[str]] = Field(
        None,
        description='A list of field IDs. When the issue changelog contains any of the fields, the webhook `jira:issue_updated` is sent. If this parameter is not present, the app is notified about all field updates.',
    )
    issuePropertyKeysFilter: Optional[List[str]] = Field(
        None,
        description='A list of issue property keys. A change of those issue properties triggers the `issue_property_set` or `issue_property_deleted` webhooks. If this parameter is not present, the app is notified about all issue property updates.',
    )
    jqlFilter: str = Field(
        ...,
        description='The JQL filter that specifies which issues the webhook is sent for. Only a subset of JQL can be used. The supported elements are:\n\n *  Fields: `issueKey`, `project`, `issuetype`, `status`, `assignee`, `reporter`, `issue.property`, and `cf[id]`. For custom fields (`cf[id]`), only the epic label custom field is supported.".\n *  Operators: `=`, `!=`, `IN`, and `NOT IN`.',
    )


class WebhookRegistrationDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    url: str = Field(
        ...,
        description='The URL that specifies where to send the webhooks. This URL must use the same base URL as the Connect app. Only a single URL per app is allowed to be registered.',
    )
    webhooks: List[WebhookDetails] = Field(..., description='A list of webhooks.')


class WebhooksExpirationDate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expirationDate: int_aliased = Field(
        ..., description='The expiration date of all the refreshed webhooks.'
    )


class WorkManagementNavigationInfo(BaseModel):
    boardName: Optional[str] = None


class Operator6(Enum):
    AND = 'AND'
    OR = 'OR'


class WorkflowIDs(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    entityId: Optional[str] = Field(None, description='The entity ID of the workflow.')
    name: str = Field(..., description='The name of the workflow.')


class WorkflowId(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    draft: bool = Field(..., description='Whether the workflow is in the draft state.')
    name: str = Field(..., description='The name of the workflow.')


class WorkflowOperations(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    canDelete: bool = Field(..., description='Whether the workflow can be deleted.')
    canEdit: bool = Field(..., description='Whether the workflow can be updated.')


class WorkflowRulesSearch(BaseModel):
    expand: Optional[str] = Field(
        None,
        description='Use expand to include additional information in the response. This parameter accepts `transition` which, for each rule, returns information about the transition the rule is assigned to.',
        examples=['transition'],
    )
    ruleIds: List[UUID] = Field(
        ..., description='The list of workflow rule IDs.', max_length=10, min_length=1
    )
    workflowEntityId: UUID = Field(
        ...,
        description='The workflow ID.',
        examples=['a498d711-685d-428d-8c3e-bc03bb450ea7'],
    )


class WorkflowSchemeIdName(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(..., description='The ID of the workflow scheme.')
    name: str = Field(..., description='The name of the workflow scheme.')


class WorkflowSchemeProjectAssociation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    projectId: str = Field(..., description='The ID of the project.')
    workflowSchemeId: Optional[str] = Field(
        None,
        description='The ID of the workflow scheme. If the workflow scheme ID is `null`, the operation assigns the default workflow scheme.',
    )


class WorkflowSimpleCondition(BaseModel):
    configuration: Optional[Dict[str, Any]] = Field(
        None, description='EXPERIMENTAL. The configuration of the transition rule.'
    )
    nodeType: Literal['simple']
    type: str = Field(..., description='The type of the transition rule.')


class WorkflowStatus(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(..., description='The ID of the issue status.')
    name: str = Field(..., description='The name of the status in the workflow.')
    properties: Optional[Dict[str, Any]] = Field(
        None,
        description='Additional properties that modify the behavior of issues in this status. Supports the properties `jira.issue.editable` and `issueEditable` (deprecated) that indicate whether issues are editable.',
    )


class WorkflowTransition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: int_aliased = Field(..., description='The transition ID.')
    name: str = Field(..., description='The transition name.')


class WorkflowTransitionProperty(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    id: Optional[str] = Field(None, description='The ID of the transition property.')
    key: Optional[str] = Field(
        None,
        description='The key of the transition property. Also known as the name of the transition property.',
    )
    value: str = Field(..., description='The value of the transition property.')


class WorkflowTransitionRule(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    configuration: Optional[Any] = Field(
        None, description='EXPERIMENTAL. The configuration of the transition rule.'
    )
    type: str = Field(..., description='The type of the transition rule.')


class WorkflowTransitionRulesDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    workflowId: WorkflowId
    workflowRuleIds: List[str] = Field(
        ..., description='The list of connect workflow rule IDs.'
    )


class WorkflowTransitionRulesUpdateErrorDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ruleUpdateErrors: Dict[str, List[str]] = Field(
        ...,
        description="A list of transition rule update errors, indexed by the transition rule ID. Any transition rule that appears here wasn't updated.",
    )
    updateErrors: List[str] = Field(
        ...,
        description='The list of errors that specify why the workflow update failed. The workflow was not updated if the list contains any entries.',
    )
    workflowId: WorkflowId


class WorkflowTransitionRulesUpdateErrors(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    updateResults: List[WorkflowTransitionRulesUpdateErrorDetails] = Field(
        ..., description='A list of workflows.'
    )


class WorkflowsWithTransitionRulesDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    workflows: List[WorkflowTransitionRulesDetails] = Field(
        ..., description='The list of workflows with transition rules to delete.'
    )


class Worklog(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    author: Optional[UserDetails] = Field(
        None, description='Details of the user who created the worklog.'
    )
    comment: Optional[Any] = Field(
        None,
        description='A comment about the worklog in [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/). Optional when creating or updating a worklog.',
    )
    created: Optional[datetime] = Field(
        None, description='The datetime on which the worklog was created.'
    )
    id: Optional[str] = Field(None, description='The ID of the worklog record.')
    issueId: Optional[str] = Field(
        None, description='The ID of the issue this worklog is for.'
    )
    properties: Optional[List[EntityProperty]] = Field(
        None,
        description='Details of properties for the worklog. Optional when creating or updating a worklog.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the worklog item.')
    started: Optional[datetime] = Field(
        None,
        description='The datetime on which the worklog effort was started. Required when creating a worklog. Optional when updating a worklog.',
    )
    timeSpent: Optional[str] = Field(
        None,
        description="The time spent working on the issue as days (\\#d), hours (\\#h), or minutes (\\#m or \\#). Required when creating a worklog if `timeSpentSeconds` isn't provided. Optional when updating a worklog. Cannot be provided if `timeSpentSecond` is provided.",
    )
    timeSpentSeconds: Optional[int_aliased] = Field(
        None,
        description="The time in seconds spent working on the issue. Required when creating a worklog if `timeSpent` isn't provided. Optional when updating a worklog. Cannot be provided if `timeSpent` is provided.",
    )
    updateAuthor: Optional[UserDetails] = Field(
        None, description='Details of the user who last updated the worklog.'
    )
    updated: Optional[datetime] = Field(
        None, description='The datetime on which the worklog was last updated.'
    )
    visibility: Optional[VisibilityModel] = Field(
        None,
        description='Details about any restrictions in the visibility of the worklog. Optional when creating or updating a worklog.',
    )


class WorklogIdsRequestBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ids: List[int_aliased] = Field(..., description='A list of worklog IDs.')


class Id(RootModel[List[int_aliased]]):
    root: List[int_aliased]


class FieldContextId(RootModel[List[int_aliased]]):
    root: List[int_aliased]


class RestApi3ApplicationPropertiesGetResponse(RootModel[List[ApplicationProperty]]):
    root: List[ApplicationProperty]


class RestApi3ApplicationPropertiesAdvancedSettingsGetResponse(
    RootModel[List[ApplicationProperty]]
):
    root: List[ApplicationProperty]


class RestApi3AttachmentContentIdGetResponse(BaseModel):
    pass


class RestApi3AttachmentThumbnailIdGetResponse(BaseModel):
    pass


class Type14(Enum):
    issuetype = 'issuetype'
    project = 'project'
    user = 'user'


class RestApi3ConfigurationTimetrackingListGetResponse(
    RootModel[List[TimeTrackingProvider]]
):
    root: List[TimeTrackingProvider]


class Filter1(Enum):
    my = 'my'
    favourite = 'favourite'


class OrderBy(Enum):
    description = 'description'
    field_description = '-description'
    field_description_1 = '+description'
    favorite_count = 'favorite_count'
    field_favorite_count = '-favorite_count'
    field_favorite_count_1 = '+favorite_count'
    id = 'id'
    field_id = '-id'
    field_id_1 = '+id'
    is_favorite = 'is_favorite'
    field_is_favorite = '-is_favorite'
    field_is_favorite_1 = '+is_favorite'
    name = 'name'
    field_name = '-name'
    field_name_1 = '+name'
    owner = 'owner'
    field_owner = '-owner'
    field_owner_1 = '+owner'


class Status3(Enum):
    active = 'active'
    archived = 'archived'
    deleted = 'deleted'


class ModuleKey(RootModel[List[str]]):
    root: List[str]


class Uri(RootModel[List[str]]):
    root: List[str]


class GadgetId(RootModel[List[int_aliased]]):
    root: List[int_aliased]


class RestApi3EventsGetResponse(RootModel[List[IssueEvent]]):
    root: List[IssueEvent]


class Check(Enum):
    syntax = 'syntax'
    type = 'type'
    complexity = 'complexity'


class TypeEnum(Enum):
    custom = 'custom'
    system = 'system'


class OrderBy2(Enum):
    contextsCount = 'contextsCount'
    field_contextsCount = '-contextsCount'
    field_contextsCount_1 = '+contextsCount'
    lastUsed = 'lastUsed'
    field_lastUsed = '-lastUsed'
    field_lastUsed_1 = '+lastUsed'
    name = 'name'
    field_name = '-name'
    field_name_1 = '+name'
    screensCount = 'screensCount'
    field_screensCount = '-screensCount'
    field_screensCount_1 = '+screensCount'
    projectsCount = 'projectsCount'
    field_projectsCount = '-projectsCount'
    field_projectsCount_1 = '+projectsCount'


class Type15(RootModel[List[TypeEnum]]):
    root: List[TypeEnum]


class Id1(RootModel[List[str]]):
    root: List[str]


class Expand(Enum):
    name = 'name'
    field_name = '-name'
    field_name_1 = '+name'
    trashDate = 'trashDate'
    field_trashDate = '-trashDate'
    field_trashDate_1 = '+trashDate'
    plannedDeletionDate = 'plannedDeletionDate'
    field_plannedDeletionDate = '-plannedDeletionDate'
    field_plannedDeletionDate_1 = '+plannedDeletionDate'
    projectsCount = 'projectsCount'
    field_projectsCount = '-projectsCount'
    field_projectsCount_1 = '+projectsCount'


class ContextId(RootModel[List[int_aliased]]):
    root: List[int_aliased]


class Id3(RootModel[List[int_aliased]]):
    root: List[int_aliased]


class FieldConfigurationSchemeId(RootModel[List[int_aliased]]):
    root: List[int_aliased] = Field(..., max_length=50, min_length=1)


class ProjectId1(RootModel[List[int_aliased]]):
    root: List[int_aliased]


class OrderBy4(Enum):
    description = 'description'
    field_description = '-description'
    field_description_1 = '+description'
    favourite_count = 'favourite_count'
    field_favourite_count = '-favourite_count'
    field_favourite_count_1 = '+favourite_count'
    id = 'id'
    field_id = '-id'
    field_id_1 = '+id'
    is_favourite = 'is_favourite'
    field_is_favourite = '-is_favourite'
    field_is_favourite_1 = '+is_favourite'
    name = 'name'
    field_name = '-name'
    field_name_1 = '+name'
    owner = 'owner'
    field_owner = '-owner'
    field_owner_1 = '+owner'
    is_shared = 'is_shared'
    field_is_shared = '-is_shared'
    field_is_shared_1 = '+is_shared'


class RestApi3FilterIdColumnsGetResponse(RootModel[List[ColumnItem]]):
    root: List[ColumnItem]


class RestApi3FilterIdColumnsPutRequest(RootModel[List[str]]):
    root: List[str]


class GroupId(RootModel[List[str]]):
    root: List[str] = Field(..., examples=['3571b9a7-348f-414a-9087-8e1ea03a7df8'])


class GroupName1(RootModel[List[str]]):
    root: List[str]


class Exclude(RootModel[List[str]]):
    root: List[str]


class ExcludeId(RootModel[List[str]]):
    root: List[str]


class AvatarSize(Enum):
    xsmall = 'xsmall'
    xsmall_2x = 'xsmall@2x'
    xsmall_3x = 'xsmall@3x'
    small = 'small'
    small_2x = 'small@2x'
    small_3x = 'small@3x'
    medium = 'medium'
    medium_2x = 'medium@2x'
    medium_3x = 'medium@3x'
    large = 'large'
    large_2x = 'large@2x'
    large_3x = 'large@3x'
    xlarge = 'xlarge'
    xlarge_2x = 'xlarge@2x'
    xlarge_3x = 'xlarge@3x'
    xxlarge = 'xxlarge'
    xxlarge_2x = 'xxlarge@2x'
    xxlarge_3x = 'xxlarge@3x'
    xxxlarge = 'xxxlarge'
    xxxlarge_2x = 'xxxlarge@2x'
    xxxlarge_3x = 'xxxlarge@3x'


class ProjectId2(RootModel[List[str]]):
    root: List[str]


class IssueTypeId(RootModel[List[str]]):
    root: List[str]


class ProjectIds1(RootModel[List[str]]):
    root: List[str]


class ProjectKeys(RootModel[List[str]]):
    root: List[str]


class IssuetypeIds(RootModel[List[str]]):
    root: List[str]


class IssuetypeNames(RootModel[List[str]]):
    root: List[str]


class DeleteSubtasks(Enum):
    true = 'true'
    false = 'false'


class Fields1(RootModel[List[str]]):
    root: List[str]


class Properties(RootModel[List[str]]):
    root: List[str]


class OrderBy6(Enum):
    created = 'created'
    field_created = '-created'
    field_created_1 = '+created'


class AdjustEstimate(Enum):
    new = 'new'
    leave = 'leave'
    manual = 'manual'
    auto = 'auto'


class IssueSecurityLevelId(RootModel[List[int_aliased]]):
    root: List[int_aliased]


class OrderBy8(Enum):
    name = 'name'
    field_name = '-name'
    field_name_1 = '+name'
    id = 'id'
    field_id = '-id'
    field_id_1 = '+id'


class IssueTypeSchemeId(RootModel[List[int_aliased]]):
    root: List[int_aliased]


class ProjectId3(RootModel[List[int_aliased]]):
    root: List[int_aliased]


class IssueTypeScreenSchemeId1(RootModel[List[int_aliased]]):
    root: List[int_aliased]


class FunctionKey(RootModel[List[str]]):
    root: List[str]


class Id8(RootModel[List[str]]):
    root: List[str]


class ProjectId5(RootModel[List[str]]):
    root: List[str]


class NotificationSchemeId1(RootModel[List[str]]):
    root: List[str]


class RestApi3PriorityGetResponse(RootModel[List[Priority]]):
    root: List[Priority]


class Properties2(RootModel[List[StringList]]):
    root: List[StringList]


class OrderBy12(Enum):
    category = 'category'
    field_category = '-category'
    field_category_1 = '+category'
    key = 'key'
    field_key = '-key'
    field_key_1 = '+key'
    name = 'name'
    field_name = '-name'
    field_name_1 = '+name'
    owner = 'owner'
    field_owner = '-owner'
    field_owner_1 = '+owner'
    issueCount = 'issueCount'
    field_issueCount = '-issueCount'
    field_issueCount_1 = '+issueCount'
    lastIssueUpdatedDate = 'lastIssueUpdatedDate'
    field_lastIssueUpdatedDate = '-lastIssueUpdatedDate'
    field_lastIssueUpdatedDate_1 = '+lastIssueUpdatedDate'
    archivedDate = 'archivedDate'
    field_archivedDate = '+archivedDate'
    field_archivedDate_1 = '-archivedDate'
    deletedDate = 'deletedDate'
    field_deletedDate = '+deletedDate'
    field_deletedDate_1 = '-deletedDate'


class Action(Enum):
    view = 'view'
    browse = 'browse'
    edit = 'edit'


class StatusEnum(Enum):
    live = 'live'
    archived = 'archived'
    deleted = 'deleted'


class Id10(RootModel[List[int_aliased]]):
    root: List[int_aliased]


class Keys(RootModel[List[str]]):
    root: List[str]


class Status5(RootModel[List[StatusEnum]]):
    root: List[StatusEnum]


class RestApi3ProjectTypeGetResponse(RootModel[List[ProjectType]]):
    root: List[ProjectType]


class RestApi3ProjectTypeAccessibleGetResponse(RootModel[List[ProjectType]]):
    root: List[ProjectType]


class ProjectTypeKey3(Enum):
    software = 'software'
    service_desk = 'service_desk'
    business = 'business'
    product_discovery = 'product_discovery'


class Properties4(RootModel[List[str]]):
    root: List[str]


class OrderBy14(Enum):
    description = 'description'
    field_description = '-description'
    field_description_1 = '+description'
    issueCount = 'issueCount'
    field_issueCount = '-issueCount'
    field_issueCount_1 = '+issueCount'
    lead = 'lead'
    field_lead = '-lead'
    field_lead_1 = '+lead'
    name = 'name'
    field_name = '-name'
    field_name_1 = '+name'


class RestApi3ProjectProjectIdOrKeyRoleGetResponse(
    RootModel[Optional[Dict[str, AnyUrl]]]
):
    root: Optional[Dict[str, AnyUrl]] = None


class NewProjectTypeKey(Enum):
    software = 'software'
    service_desk = 'service_desk'
    business = 'business'


class OrderBy16(Enum):
    description = 'description'
    field_description = '-description'
    field_description_1 = '+description'
    name = 'name'
    field_name = '-name'
    field_name_1 = '+name'
    releaseDate = 'releaseDate'
    field_releaseDate = '-releaseDate'
    field_releaseDate_1 = '+releaseDate'
    sequence = 'sequence'
    field_sequence = '-sequence'
    field_sequence_1 = '+sequence'
    startDate = 'startDate'
    field_startDate = '-startDate'
    field_startDate_1 = '+startDate'


class RestApi3ProjectCategoryGetResponse(RootModel[List[ProjectCategory]]):
    root: List[ProjectCategory]


class RestApi3ResolutionGetResponse(RootModel[List[Resolution]]):
    root: List[Resolution]


class Id11(RootModel[List[str]]):
    root: List[str]


class ScopeEnum(Enum):
    GLOBAL = 'GLOBAL'
    TEMPLATE = 'TEMPLATE'
    PROJECT = 'PROJECT'


class OrderBy18(Enum):
    name = 'name'
    field_name = '-name'
    field_name_1 = '+name'
    id = 'id'
    field_id = '-id'
    field_id_1 = '+id'


class Id12(RootModel[List[int_aliased]]):
    root: List[int_aliased]


class Scope2(RootModel[List[ScopeEnum]]):
    root: List[ScopeEnum]


class RestApi3ScreensScreenIdAvailableFieldsGetResponse(
    RootModel[List[ScreenableField]]
):
    root: List[ScreenableField]


class RestApi3ScreensScreenIdTabsGetResponse(RootModel[List[ScreenableTab]]):
    root: List[ScreenableTab]


class RestApi3ScreensScreenIdTabsTabIdFieldsGetResponse(
    RootModel[List[ScreenableField]]
):
    root: List[ScreenableField]


class RestApi3SettingsColumnsGetResponse(RootModel[List[ColumnItem]]):
    root: List[ColumnItem]


class RestApi3SettingsColumnsPutRequest(RootModel[List[str]]):
    root: List[str]


class RestApi3StatusGetResponse(RootModel[List[StatusDetails]]):
    root: List[StatusDetails]


class RestApi3StatuscategoryGetResponse(RootModel[List[StatusCategory1]]):
    root: List[StatusCategory1]


class Id14(RootModel[List[str]]):
    root: List[str]


class RestApi3TaskTaskIdCancelPostResponse(RootModel[List[str]]):
    root: List[str]


class Type16(Enum):
    project = 'project'
    issuetype = 'issuetype'


class Size(Enum):
    xsmall = 'xsmall'
    small = 'small'
    medium = 'medium'
    large = 'large'
    xlarge = 'xlarge'


class Format(Enum):
    png = 'png'
    svg = 'svg'


class RestApi3UniversalAvatarViewTypeTypeGetResponse(BaseModel):
    pass


class Type19(Enum):
    issuetype = 'issuetype'
    project = 'project'


class RestApi3UniversalAvatarViewTypeTypeAvatarIdGetResponse(BaseModel):
    pass


class RestApi3UniversalAvatarViewTypeTypeOwnerEntityIdGetResponse(BaseModel):
    pass


class AccountIdItem(RootModel[constr(max_length=128)]):
    root: constr(max_length=128) = Field(..., examples=['5b10ac8d82e05b22cc7d4ef5'])


class Username(RootModel[List[str]]):
    root: List[str]


class Key(RootModel[List[str]]):
    root: List[str]


class AccountId(RootModel[List[AccountIdItem]]):
    root: List[AccountIdItem] = Field(
        ..., examples=['5b10ac8d82e05b22cc7d4ef5'], max_length=128
    )


class RestApi3UserBulkMigrationGetResponse(RootModel[List[UserMigrationBean]]):
    root: List[UserMigrationBean]


class RestApi3UserColumnsGetResponse(RootModel[List[ColumnItem]]):
    root: List[ColumnItem]


class RestApi3UserColumnsPutRequest(RootModel[List[str]]):
    root: List[str]


class AccountIdItem2(RootModel[constr(max_length=128)]):
    root: constr(max_length=128)


class AccountId1(RootModel[List[AccountIdItem2]]):
    root: List[AccountIdItem2] = Field(..., max_length=128)


class RestApi3UserGroupsGetResponse(RootModel[List[GroupName]]):
    root: List[GroupName]


class ExcludeAccountIds(RootModel[List[str]]):
    root: List[str]


class Type22(Enum):
    postfunction = 'postfunction'
    condition = 'condition'
    validator = 'validator'


class WorkflowName(RootModel[constr(max_length=50)]):
    root: constr(max_length=50)


class WithTag(RootModel[constr(max_length=20)]):
    root: constr(max_length=20)


class Types(RootModel[List[Type22]]):
    root: List[Type22]


class WorkflowNames(RootModel[List[WorkflowName]]):
    root: List[WorkflowName] = Field(..., max_length=50)


class WithTags(RootModel[List[WithTag]]):
    root: List[WithTag] = Field(..., max_length=20)


class OrderBy22(Enum):
    name = 'name'
    field_name = '-name'
    field_name_1 = '+name'
    created = 'created'
    field_created = '-created'
    field_created_1 = '+created'
    updated = 'updated'
    field_updated = '+updated'
    field_updated_1 = '-updated'


class WorkflowName2(RootModel[List[str]]):
    root: List[str]


class WorkflowMode(Enum):
    live = 'live'
    draft = 'draft'


class ProjectId7(RootModel[List[int_aliased]]):
    root: List[int_aliased] = Field(..., max_length=100, min_length=1)


class RestApi3WorklogListPostResponse(RootModel[List[Worklog]]):
    root: List[Worklog]


class RestAtlassianConnect1MigrationPropertiesEntityTypePutRequest(
    RootModel[List[EntityPropertyDetails]]
):
    root: List[EntityPropertyDetails] = Field(..., max_length=50, min_length=1)


class EntityType(Enum):
    IssueProperty = 'IssueProperty'
    CommentProperty = 'CommentProperty'
    DashboardItemProperty = 'DashboardItemProperty'
    IssueTypeProperty = 'IssueTypeProperty'
    ProjectProperty = 'ProjectProperty'
    UserProperty = 'UserProperty'
    WorklogProperty = 'WorklogProperty'
    BoardProperty = 'BoardProperty'
    SprintProperty = 'SprintProperty'


class ApplicationRole(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    defaultGroups: Optional[List[str]] = Field(
        None,
        description="The groups that are granted default access for this application role. As a group's name can change, use of `defaultGroupsDetails` is recommended to identify a groups.",
    )
    defaultGroupsDetails: Optional[List[GroupName]] = Field(
        None,
        description='The groups that are granted default access for this application role.',
    )
    defined: Optional[bool] = Field(None, description='Deprecated.')
    groupDetails: Optional[List[GroupName]] = Field(
        None, description='The groups associated with the application role.'
    )
    groups: Optional[List[str]] = Field(
        None,
        description="The groups associated with the application role. As a group's name can change, use of `groupDetails` is recommended to identify a groups.",
    )
    hasUnlimitedSeats: Optional[bool] = None
    key: Optional[str] = Field(None, description='The key of the application role.')
    name: Optional[str] = Field(
        None, description='The display name of the application role.'
    )
    numberOfSeats: Optional[int_aliased] = Field(
        None, description='The maximum count of users on your license.'
    )
    platform: Optional[bool] = Field(
        None,
        description='Indicates if the application role belongs to Jira platform (`jira-core`).',
    )
    remainingSeats: Optional[int_aliased] = Field(
        None, description='The count of users remaining on your license.'
    )
    selectedByDefault: Optional[bool] = Field(
        None,
        description='Determines whether this application role should be selected by default on user creation.',
    )
    userCount: Optional[int_aliased] = Field(
        None, description='The number of users counting against your license.'
    )
    userCountDescription: Optional[str] = Field(
        None,
        description='The [type of users](https://confluence.atlassian.com/x/lRW3Ng) being counted against your license.',
    )


class AssociateFieldConfigurationsWithIssueTypesRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mappings: List[FieldConfigurationToIssueTypeMapping] = Field(
        ..., description='Field configuration to issue type mappings.'
    )


class Attachment(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    author: Optional[UserDetails] = Field(
        None, description='Details of the user who added the attachment.'
    )
    content: Optional[str] = Field(None, description='The content of the attachment.')
    created: Optional[datetime] = Field(
        None, description='The datetime the attachment was created.'
    )
    filename: Optional[str] = Field(
        None, description='The file name of the attachment.'
    )
    id: Optional[str] = Field(None, description='The ID of the attachment.')
    mimeType: Optional[str] = Field(
        None, description='The MIME type of the attachment.'
    )
    self: Optional[str] = Field(
        None, description='The URL of the attachment details response.'
    )
    size: Optional[int_aliased] = Field(None, description='The size of the attachment.')
    thumbnail: Optional[str] = Field(
        None, description='The URL of a thumbnail representing the attachment.'
    )


class AttachmentArchive(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    entries: Optional[List[AttachmentArchiveEntry]] = None
    moreAvailable: Optional[bool] = None
    totalEntryCount: Optional[int_aliased] = None
    totalNumberOfEntriesAvailable: Optional[int_aliased] = None


class AuditRecordBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    associatedItems: Optional[List[AssociatedItemBean]] = Field(
        None, description='The list of items associated with the changed record.'
    )
    authorKey: Optional[str] = Field(
        None,
        description='Deprecated, use `authorAccountId` instead. The key of the user who created the audit record.',
    )
    category: Optional[str] = Field(
        None,
        description='The category of the audit record. For a list of these categories, see the help article [Auditing in Jira applications](https://confluence.atlassian.com/x/noXKM).',
    )
    changedValues: Optional[List[ChangedValueBean]] = Field(
        None, description='The list of values changed in the record event.'
    )
    created: Optional[datetime] = Field(
        None, description='The date and time on which the audit record was created.'
    )
    description: Optional[str] = Field(
        None, description='The description of the audit record.'
    )
    eventSource: Optional[str] = Field(
        None, description='The event the audit record originated from.'
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the audit record.')
    objectItem: Optional[AssociatedItemBean] = None
    remoteAddress: Optional[str] = Field(
        None,
        description='The URL of the computer where the creation of the audit record was initiated.',
    )
    summary: Optional[str] = Field(None, description='The summary of the audit record.')


class AuditRecords(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    limit: Optional[int_aliased] = Field(
        None,
        description='The requested or default limit on the number of audit items to be returned.',
    )
    offset: Optional[int_aliased] = Field(
        None,
        description='The number of audit items skipped before the first item in this list.',
    )
    records: Optional[List[AuditRecordBean]] = Field(
        None, description='The list of audit items.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The total number of audit items returned.'
    )


class BulkCustomFieldOptionCreateRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    options: Optional[List[CustomFieldOptionCreate]] = Field(
        None, description='Details of options to create.'
    )


class BulkCustomFieldOptionUpdateRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    options: Optional[List[CustomFieldOptionUpdate]] = Field(
        None, description='Details of the options to update.'
    )


class BulkIssuePropertyUpdateRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expression: Optional[str] = Field(
        None,
        description='EXPERIMENTAL. The Jira expression to calculate the value of the property. The value of the expression must be an object that can be converted to JSON, such as a number, boolean, string, list, or map. The context variables available to the expression are `issue` and `user`. Issues for which the expression returns a value whose JSON representation is longer than 32768 characters are ignored.',
    )
    filter: Optional[IssueFilterForBulkPropertySet] = Field(
        None, description='The bulk operation filter.'
    )
    value: Optional[Any] = Field(
        None,
        description='The value of the property. The value must be a [valid](https://tools.ietf.org/html/rfc4627), non-empty JSON blob. The maximum length is 32768 characters.',
    )


class BulkOperationErrorResult(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    elementErrors: Optional[ErrorCollection] = None
    failedElementNumber: Optional[int_aliased] = None
    status: Optional[int_aliased] = None


class BulkPermissionGrants(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    globalPermissions: List[str] = Field(
        ..., description='List of permissions granted to the user.'
    )
    projectPermissions: List[BulkProjectPermissionGrants] = Field(
        ...,
        description='List of project permissions and the projects and issues those permissions provide access to.',
    )


class BulkPermissionsRequestBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountId: Optional[str] = Field(None, description='The account ID of a user.')
    globalPermissions: Optional[List[str]] = Field(
        None, description='Global permissions to look up.'
    )
    projectPermissions: Optional[List[BulkProjectPermissions]] = Field(
        None,
        description='Project permissions with associated projects and issues to look up.',
    )


class ChangedWorklog(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    properties: Optional[List[EntityProperty]] = Field(
        None, description='Details of properties associated with the change.'
    )
    updatedTime: Optional[int_aliased] = Field(
        None, description='The datetime of the change.'
    )
    worklogId: Optional[int_aliased] = Field(None, description='The ID of the worklog.')


class ChangedWorklogs(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    lastPage: Optional[bool] = None
    nextPage: Optional[AnyUrl] = Field(
        None, description='The URL of the next list of changed worklogs.'
    )
    self: Optional[AnyUrl] = Field(
        None, description='The URL of this changed worklogs list.'
    )
    since: Optional[int_aliased] = Field(
        None, description='The datetime of the first worklog item in the list.'
    )
    until: Optional[int_aliased] = Field(
        None, description='The datetime of the last worklog item in the list.'
    )
    values: Optional[List[ChangedWorklog]] = Field(
        None, description='Changed worklog list.'
    )


class Comment(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    author: Optional[UserDetails] = Field(
        None, description='The ID of the user who created the comment.'
    )
    body: Optional[Any] = Field(
        None,
        description='The comment text in [Atlassian Document Format](https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/).',
    )
    created: Optional[datetime] = Field(
        None, description='The date and time at which the comment was created.'
    )
    id: Optional[str] = Field(None, description='The ID of the comment.')
    jsdAuthorCanSeeRequest: Optional[bool] = Field(
        None,
        description='Whether the comment was added from an email sent by a person who is not part of the issue. See [Allow external emails to be added as comments on issues](https://support.atlassian.com/jira-service-management-cloud/docs/allow-external-emails-to-be-added-as-comments-on-issues/)for information on setting up this feature.',
    )
    jsdPublic: Optional[bool] = Field(
        None,
        description="Whether the comment is visible in Jira Service Desk. Defaults to true when comments are created in the Jira Cloud Platform. This includes when the site doesn't use Jira Service Desk or the project isn't a Jira Service Desk project and, therefore, there is no Jira Service Desk for the issue to be visible on. To create a comment with its visibility in Jira Service Desk set to false, use the Jira Service Desk REST API [Create request comment](https://developer.atlassian.com/cloud/jira/service-desk/rest/#api-rest-servicedeskapi-request-issueIdOrKey-comment-post) operation.",
    )
    properties: Optional[List[EntityProperty]] = Field(
        None, description='A list of comment properties. Optional on create and update.'
    )
    renderedBody: Optional[str] = Field(
        None, description='The rendered version of the comment.'
    )
    self: Optional[str] = Field(None, description='The URL of the comment.')
    updateAuthor: Optional[UserDetails] = Field(
        None, description='The ID of the user who updated the comment last.'
    )
    updated: Optional[datetime] = Field(
        None, description='The date and time at which the comment was updated last.'
    )
    visibility: Optional[VisibilityModel] = Field(
        None,
        description='The group or role to which this comment is visible. Optional on create and update.',
    )


class Configuration(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    attachmentsEnabled: Optional[bool] = Field(
        None, description='Whether the ability to add attachments to issues is enabled.'
    )
    issueLinkingEnabled: Optional[bool] = Field(
        None, description='Whether the ability to link issues is enabled.'
    )
    subTasksEnabled: Optional[bool] = Field(
        None,
        description='Whether the ability to create subtasks for issues is enabled.',
    )
    timeTrackingConfiguration: Optional[TimeTrackingConfiguration] = Field(
        None, description='The configuration of time tracking.'
    )
    timeTrackingEnabled: Optional[bool] = Field(
        None,
        description='Whether the ability to track time is enabled. This property is deprecated.',
    )
    unassignedIssuesAllowed: Optional[bool] = Field(
        None,
        description='Whether the ability to create unassigned issues is enabled. See [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM) for details.',
    )
    votingEnabled: Optional[bool] = Field(
        None,
        description='Whether the ability for users to vote on issues is enabled. See [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM) for details.',
    )
    watchingEnabled: Optional[bool] = Field(
        None,
        description='Whether the ability for users to watch issues is enabled. See [Configuring Jira application options](https://confluence.atlassian.com/x/uYXKM) for details.',
    )


class ConnectWorkflowTransitionRule(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    configuration: RuleConfiguration
    id: str = Field(..., description='The ID of the transition rule.')
    key: str = Field(
        ...,
        description='The key of the rule, as defined in the Connect app descriptor.',
    )
    transition: Optional[WorkflowTransition] = None


class ContainerForProjectFeatures(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    features: Optional[List[ProjectFeature]] = Field(
        None, description='The project features.'
    )


class ContainerForRegisteredWebhooks(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    webhookRegistrationResult: Optional[List[RegisteredWebhook]] = Field(
        None, description='A list of registered webhooks.'
    )


class ConvertedJQLQueries(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    queriesWithUnknownUsers: Optional[List[JQLQueryWithUnknownUsers]] = Field(
        None,
        description='List of queries containing user information that could not be mapped to an existing user',
    )
    queryStrings: Optional[List[str]] = Field(
        None,
        description='The list of converted query strings with account IDs in place of user identifiers.',
    )


class CreateUiModificationDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    contexts: Optional[List[UiModificationContextDetails]] = Field(
        None,
        description='List of contexts of the UI modification. The maximum number of contexts is 1000.',
    )
    data: Optional[str] = Field(
        None,
        description='The data of the UI modification. The maximum size of the data is 50000 characters.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the UI modification. The maximum length is 255 characters.',
    )
    name: str = Field(
        ...,
        description='The name of the UI modification. The maximum length is 255 characters.',
    )


class CreateWorkflowTransitionDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the transition. The maximum length is 1000 characters.',
    )
    from_: Optional[List[str]] = Field(
        None, alias='from', description='The statuses the transition can start from.'
    )
    name: str = Field(
        ...,
        description='The name of the transition. The maximum length is 60 characters.',
    )
    properties: Optional[Dict[str, str]] = Field(
        None, description='The properties of the transition.'
    )
    rules: Optional[CreateWorkflowTransitionRulesDetails] = Field(
        None, description='The rules of the transition.'
    )
    screen: Optional[CreateWorkflowTransitionScreenDetails] = Field(
        None, description='The screen of the transition.'
    )
    to: str = Field(..., description='The status the transition goes to.')
    type: Type = Field(..., description='The type of the transition.')


class CustomContextVariable1(UserContextVariable):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Literal['user'] = Field(..., description='Type of custom context variable.')


class CustomContextVariable2(IssueContextVariable):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Literal['issue'] = Field(..., description='Type of custom context variable.')


class CustomContextVariable3(JsonContextVariable):
    model_config = ConfigDict(
        extra='forbid',
    )
    type: Literal['json'] = Field(..., description='Type of custom context variable.')


class CustomContextVariable(
    RootModel[
        Union[CustomContextVariable1, CustomContextVariable2, CustomContextVariable3]
    ]
):
    root: Union[
        CustomContextVariable1, CustomContextVariable2, CustomContextVariable3
    ] = Field(..., discriminator='type')


class CustomFieldContextDefaultValueForgeUserField(BaseModel):
    accountId: str = Field(..., description='The ID of the default user.')
    contextId: str = Field(..., description='The ID of the context.')
    type: Literal['forge.user']
    userFilter: UserFilter


class CustomFieldContextSingleUserPickerDefaults(BaseModel):
    accountId: str = Field(..., description='The ID of the default user.')
    contextId: str = Field(..., description='The ID of the context.')
    type: Literal['single.user.select']
    userFilter: UserFilter


class DashboardGadget(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    color: Color = Field(
        ...,
        description='The color of the gadget. Should be one of `blue`, `red`, `yellow`, `green`, `cyan`, `purple`, `gray`, or `white`.',
    )
    id: int_aliased = Field(..., description='The ID of the gadget instance.')
    moduleKey: Optional[str] = Field(
        None, description='The module key of the gadget type.'
    )
    position: DashboardGadgetPosition = Field(
        ..., description='The position of the gadget.'
    )
    title: str = Field(..., description='The title of the gadget.')
    uri: Optional[str] = Field(None, description='The URI of the gadget type.')


class DashboardGadgetResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    gadgets: List[DashboardGadget] = Field(..., description='The list of gadgets.')


class FieldModel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    contextsCount: Optional[int_aliased] = Field(
        None, description='Number of contexts where the field is used.'
    )
    description: Optional[str] = Field(
        None, description='The description of the field.'
    )
    id: str = Field(..., description='The ID of the field.')
    isLocked: Optional[bool] = Field(None, description='Whether the field is locked.')
    isUnscreenable: Optional[bool] = Field(
        None, description='Whether the field is shown on screen or not.'
    )
    key: Optional[str] = Field(None, description='The key of the field.')
    lastUsed: Optional[FieldLastUsed] = None
    name: str = Field(..., description='The name of the field.')
    projectsCount: Optional[int_aliased] = Field(
        None, description='Number of projects where the field is used.'
    )
    schema_: JsonTypeBean = Field(..., alias='schema')
    screensCount: Optional[int_aliased] = Field(
        None, description='Number of screens where the field is used.'
    )
    searcherKey: Optional[str] = Field(
        None, description='The searcher key of the field. Returned for custom fields.'
    )


class FieldMetadata(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allowedValues: Optional[List[Any]] = Field(
        None, description='The list of values allowed in the field.'
    )
    autoCompleteUrl: Optional[str] = Field(
        None,
        description='The URL that can be used to automatically complete the field.',
    )
    configuration: Optional[Dict[str, Any]] = Field(
        None, description='The configuration properties.'
    )
    defaultValue: Optional[Any] = Field(
        None, description='The default value of the field.'
    )
    hasDefaultValue: Optional[bool] = Field(
        None, description='Whether the field has a default value.'
    )
    key: str = Field(..., description='The key of the field.')
    name: str = Field(..., description='The name of the field.')
    operations: List[str] = Field(
        ..., description='The list of operations that can be performed on the field.'
    )
    required: bool = Field(..., description='Whether the field is required.')
    schema_: JsonTypeBean = Field(
        ..., alias='schema', description='The data type of the field.'
    )


class FoundGroup(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    groupId: Optional[str] = Field(
        None,
        description='The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.',
    )
    html: Optional[str] = Field(
        None,
        description='The group name with the matched query string highlighted with the HTML bold tag.',
    )
    labels: Optional[List[GroupLabel]] = None
    name: Optional[str] = Field(
        None,
        description='The name of the group. The name of a group is mutable, to reliably identify a group use ``groupId`.`',
    )


class FoundGroups(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    groups: Optional[List[FoundGroup]] = None
    header: Optional[str] = Field(
        None,
        description='Header text indicating the number of groups in the response and the total number of groups found in the search.',
    )
    total: Optional[int_aliased] = Field(
        None, description='The total number of groups found in the search.'
    )


class FoundUsers(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    header: Optional[str] = Field(
        None,
        description='Header text indicating the number of users in the response and the total number of users found in the search.',
    )
    total: Optional[int_aliased] = Field(
        None, description='The total number of users found in the search.'
    )
    users: Optional[List[UserPickerUser]] = None


class FoundUsersAndGroups(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    groups: Optional[FoundGroups] = None
    users: Optional[FoundUsers] = None


class Hierarchy(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    baseLevelId: Optional[int_aliased] = Field(
        None,
        description='The ID of the base level. This property is deprecated, see [Change notice: Removing hierarchy level IDs from next-gen APIs](https://developer.atlassian.com/cloud/jira/platform/change-notice-removing-hierarchy-level-ids-from-next-gen-apis/).',
    )
    levels: Optional[List[SimplifiedHierarchyLevel]] = Field(
        None, description='Details about the hierarchy level.'
    )


class HistoryMetadata(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    activityDescription: Optional[str] = Field(
        None, description='The activity described in the history record.'
    )
    activityDescriptionKey: Optional[str] = Field(
        None, description='The key of the activity described in the history record.'
    )
    actor: Optional[HistoryMetadataParticipant] = Field(
        None, description='Details of the user whose action created the history record.'
    )
    cause: Optional[HistoryMetadataParticipant] = Field(
        None,
        description='Details of the cause that triggered the creation the history record.',
    )
    description: Optional[str] = Field(
        None, description='The description of the history record.'
    )
    descriptionKey: Optional[str] = Field(
        None, description='The description key of the history record.'
    )
    emailDescription: Optional[str] = Field(
        None,
        description='The description of the email address associated the history record.',
    )
    emailDescriptionKey: Optional[str] = Field(
        None,
        description='The description key of the email address associated the history record.',
    )
    extraData: Optional[Dict[str, str]] = Field(
        None, description='Additional arbitrary information about the history record.'
    )
    generator: Optional[HistoryMetadataParticipant] = Field(
        None, description='Details of the system that generated the history record.'
    )
    type: Optional[str] = Field(None, description='The type of the history record.')


class IssueEntityProperties(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    entitiesIds: Optional[List[int_aliased]] = Field(
        None,
        description='A list of entity property IDs.',
        max_length=10000,
        min_length=1,
    )
    properties: Optional[Dict[str, JsonNode]] = Field(
        None, description='A list of entity property keys and values.'
    )


class IssueEntityPropertiesForMultiUpdate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issueID: Optional[int_aliased] = Field(None, description='The ID of the issue.')
    properties: Optional[Dict[str, JsonNode]] = Field(
        None,
        description='Entity properties to set on the issue. The maximum length of an issue property value is 32768 characters.',
    )


class IssueFieldOptionScopeBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    global_: Optional[GlobalScopeBean] = Field(
        None,
        alias='global',
        description='Defines the behavior of the option within the global context. If this property is set, even if set to an empty object, then the option is available in all projects.',
    )
    projects: Optional[List[int_aliased]] = Field(None, description='DEPRECATED')
    projects2: Optional[List[ProjectScopeBean]] = Field(
        None,
        description='Defines the projects in which the option is available and the behavior of the option within each project. Specify one object per project. The behavior of the option in a project context overrides the behavior in the global context.',
    )


class IssueMatches(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    matches: List[IssueMatchesForJQL]


class IssuePickerSuggestionsIssueType(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(
        None,
        description='The ID of the type of issues suggested for use in auto-completion.',
    )
    issues: Optional[List[SuggestedIssue]] = Field(
        None, description='A list of issues suggested for use in auto-completion.'
    )
    label: Optional[str] = Field(
        None,
        description='The label of the type of issues suggested for use in auto-completion.',
    )
    msg: Optional[str] = Field(
        None,
        description='If no issue suggestions are found, returns a message indicating no suggestions were found,',
    )
    sub: Optional[str] = Field(
        None,
        description='If issue suggestions are found, returns a message indicating the number of issues suggestions found and returned.',
    )


class IssueSecurityLevelMember(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    holder: PermissionHolder = Field(
        ...,
        description='The user or group being granted the permission. It consists of a `type` and a type-dependent `parameter`. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information.',
    )
    id: int_aliased = Field(
        ..., description='The ID of the issue security level member.'
    )
    issueSecurityLevelId: int_aliased = Field(
        ..., description='The ID of the issue security level.'
    )


class IssueTransition(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional transition details in the response.',
    )
    fields: Optional[Dict[str, FieldMetadata]] = Field(
        None,
        description='Details of the fields associated with the issue transition screen. Use this information to populate `fields` and `update` in a transition request.',
    )
    hasScreen: Optional[bool] = Field(
        None,
        description='Whether there is a screen associated with the issue transition.',
    )
    id: Optional[str] = Field(
        None,
        description='The ID of the issue transition. Required when specifying a transition to undertake.',
    )
    isAvailable: Optional[bool] = Field(
        None, description='Whether the transition is available to be performed.'
    )
    isConditional: Optional[bool] = Field(
        None,
        description='Whether the issue has to meet criteria before the issue transition is applied.',
    )
    isGlobal: Optional[bool] = Field(
        None,
        description='Whether the issue transition is global, that is, the transition is applied to issues regardless of their status.',
    )
    isInitial: Optional[bool] = Field(
        None,
        description='Whether this is the initial issue transition for the workflow.',
    )
    looped: Optional[bool] = None
    name: Optional[str] = Field(None, description='The name of the issue transition.')
    to: Optional[StatusDetails] = Field(
        None, description='Details of the issue status after the transition.'
    )


class IssueTypeScreenSchemeDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the issue type screen scheme. The maximum length is 255 characters.',
    )
    issueTypeMappings: List[IssueTypeScreenSchemeMapping] = Field(
        ...,
        description='The IDs of the screen schemes for the issue type IDs and *default*. A *default* entry is required to create an issue type screen scheme, it defines the mapping for all issue types without a screen scheme.',
    )
    name: str = Field(
        ...,
        description='The name of the issue type screen scheme. The name must be unique. The maximum length is 255 characters.',
    )


class IssueTypeWithStatus(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: str = Field(..., description='The ID of the issue type.')
    name: str = Field(..., description='The name of the issue type.')
    self: str = Field(..., description="The URL of the issue type's status details.")
    statuses: List[StatusDetails] = Field(
        ..., description='List of status details for the issue type.'
    )
    subtask: bool = Field(
        ..., description='Whether this issue type represents subtasks.'
    )


class IssueUpdateDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    fields: Optional[Dict[str, Any]] = Field(
        None,
        description='List of issue screen fields to update, specifying the sub-field to update and its value for each field. This field provides a straightforward option when setting a sub-field. When multiple sub-fields or other operations are required, use `update`. Fields included in here cannot be included in `update`.',
    )
    historyMetadata: Optional[HistoryMetadata] = Field(
        None, description='Additional issue history details.'
    )
    properties: Optional[List[EntityProperty]] = Field(
        None, description='Details of issue properties to be add or update.'
    )
    transition: Optional[IssueTransition] = Field(
        None,
        description='Details of a transition. Required when performing a transition, optional when creating or editing an issue.',
    )
    update: Optional[Dict[str, List[FieldUpdateOperation]]] = Field(
        None,
        description='A Map containing the field field name and a list of operations to perform on the issue screen field. Note that fields included in here cannot be included in `fields`.',
    )


class IssueUpdateMetadata(BaseModel):
    fields: Optional[Dict[str, FieldMetadata]] = None


class IssuesUpdateBean(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    issueUpdates: Optional[List[IssueUpdateDetails]] = None


class JexpIssues(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    jql: Optional[JexpJqlIssues] = Field(
        None,
        description='The JQL query that specifies the set of issues available in the Jira expression.',
    )


class JiraExpressionAnalysis(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    complexity: Optional[JiraExpressionComplexity] = None
    errors: Optional[List[JiraExpressionValidationError]] = Field(
        None,
        description='A list of validation errors. Not included if the expression is valid.',
    )
    expression: str = Field(..., description='The analysed expression.')
    type: Optional[str] = Field(
        None, description='EXPERIMENTAL. The inferred type of the expression.'
    )
    valid: bool = Field(
        ...,
        description='Whether the expression is valid and the interpreter will evaluate it. Note that the expression may fail at runtime (for example, if it executes too many expensive operations).',
    )


class JiraExpressionEvalContextBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    board: Optional[int_aliased] = Field(
        None,
        description='The ID of the board that is available under the `board` variable when evaluating the expression.',
    )
    custom: Optional[List[CustomContextVariable]] = Field(
        None,
        description='Custom context variables and their types. These variable types are available for use in a custom context:\n\n *  `user`: A [user](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#user) specified as an Atlassian account ID.\n *  `issue`: An [issue](https://developer.atlassian.com/cloud/jira/platform/jira-expressions-type-reference#issue) specified by ID or key. All the fields of the issue object are available in the Jira expression.\n *  `json`: A JSON object containing custom content.\n *  `list`: A JSON list of `user`, `issue`, or `json` variable types.',
    )
    customerRequest: Optional[int_aliased] = Field(
        None,
        description='The ID of the customer request that is available under the `customerRequest` variable when evaluating the expression. This is the same as the ID of the underlying Jira issue, but the customer request context variable will have a different type.',
    )
    issue: Optional[IdOrKeyBean] = Field(
        None,
        description='The issue that is available under the `issue` variable when evaluating the expression.',
    )
    issues: Optional[JexpIssues] = Field(
        None,
        description='The collection of issues that is available under the `issues` variable when evaluating the expression.',
    )
    project: Optional[IdOrKeyBean] = Field(
        None,
        description='The project that is available under the `project` variable when evaluating the expression.',
    )
    serviceDesk: Optional[int_aliased] = Field(
        None,
        description='The ID of the service desk that is available under the `serviceDesk` variable when evaluating the expression.',
    )
    sprint: Optional[int_aliased] = Field(
        None,
        description='The ID of the sprint that is available under the `sprint` variable when evaluating the expression.',
    )


class JiraExpressionEvalRequestBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    context: Optional[JiraExpressionEvalContextBean] = Field(
        None, description='The context in which the Jira expression is evaluated.'
    )
    expression: str = Field(
        ...,
        description='The Jira expression to evaluate.',
        examples=[
            '{ key: issue.key, type: issue.issueType.name, links: issue.links.map(link => link.linkedIssue.id) }'
        ],
    )


class JiraExpressionsAnalysis(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    results: List[JiraExpressionAnalysis] = Field(
        ..., description='The results of Jira expressions analysis.'
    )


class JiraExpressionsComplexityBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    beans: JiraExpressionsComplexityValueBean = Field(
        ..., description='The number of Jira REST API beans returned in the response.'
    )
    expensiveOperations: JiraExpressionsComplexityValueBean = Field(
        ...,
        description='The number of expensive operations executed while evaluating the expression. Expensive operations are those that load additional data, such as entity properties, comments, or custom fields.',
    )
    primitiveValues: JiraExpressionsComplexityValueBean = Field(
        ..., description='The number of primitive values returned in the response.'
    )
    steps: JiraExpressionsComplexityValueBean = Field(
        ...,
        description='The number of steps it took to evaluate the expression, where a step is a high-level operation performed by the expression. A step is an operation such as arithmetic, accessing a property, accessing a context variable, or calling a function.',
    )


class JiraStatus(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the status.'
    )
    id: Optional[str] = Field(None, description='The ID of the status.')
    name: Optional[str] = Field(None, description='The name of the status.')
    scope: Optional[StatusScope] = None
    statusCategory: Optional[StatusCategory] = Field(
        None, description='The category of the status.'
    )
    usages: Optional[List[ProjectIssueTypes]] = Field(
        None,
        description='Projects and issue types where the status is used. Only available if the `usages` expand is requested.',
    )


class JqlQueriesToSanitize(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    queries: List[JqlQueryToSanitize] = Field(
        ...,
        description='The list of JQL queries to sanitize. Must contain unique values. Maximum of 20 queries.',
    )


class JqlQueryField(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    encodedName: Optional[str] = Field(
        None,
        description='The encoded name of the field, which can be used directly in a JQL query.',
    )
    name: str = Field(..., description='The name of the field.')
    property: Optional[List[JqlQueryFieldEntityProperty]] = Field(
        None,
        description='When the field refers to a value in an entity property, details of the entity property value.',
    )


class JqlQueryOrderByClauseElement(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    direction: Optional[Direction] = Field(
        None, description='The direction in which to order the results.'
    )
    field: JqlQueryField


class JqlQueryUnitaryOperand(
    RootModel[Union[ValueOperand, FunctionOperand, KeywordOperand]]
):
    root: Union[ValueOperand, FunctionOperand, KeywordOperand] = Field(
        ..., description='An operand that can be part of a list operand.'
    )


class License(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    applications: List[LicensedApplication] = Field(
        ..., description='The applications under this license.'
    )


class LinkGroup(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    groups: Optional[List[LinkGroup]] = None
    header: Optional[SimpleLink] = None
    id: Optional[str] = None
    links: Optional[List[SimpleLink]] = None
    styleClass: Optional[str] = None
    weight: Optional[int_aliased] = None


class ListOperand(BaseModel):
    encodedOperand: Optional[str] = Field(
        None, description='Encoded operand, which can be used directly in a JQL query.'
    )
    values: List[JqlQueryUnitaryOperand] = Field(
        ..., description='The list of operand values.', min_length=1
    )


class MultiIssueEntityProperties(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    issues: Optional[List[IssueEntityPropertiesForMultiUpdate]] = Field(
        None, description='A list of issue IDs and their respective properties.'
    )


class NestedResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    errorCollection: Optional[ErrorCollection] = None
    status: Optional[int_aliased] = None
    warningCollection: Optional[WarningCollection] = None


class NotificationRecipients(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    assignee: Optional[bool] = Field(
        None,
        description="Whether the notification should be sent to the issue's assignees.",
    )
    groupIds: Optional[List[str]] = Field(
        None, description='List of groupIds to receive the notification.'
    )
    groups: Optional[List[GroupName]] = Field(
        None, description='List of groups to receive the notification.'
    )
    reporter: Optional[bool] = Field(
        None,
        description="Whether the notification should be sent to the issue's reporter.",
    )
    users: Optional[List[UserDetails]] = Field(
        None, description='List of users to receive the notification.'
    )
    voters: Optional[bool] = Field(
        None,
        description="Whether the notification should be sent to the issue's voters.",
    )
    watchers: Optional[bool] = Field(
        None,
        description="Whether the notification should be sent to the issue's watchers.",
    )


class NotificationRecipientsRestrictions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    groupIds: Optional[List[str]] = Field(
        None,
        description='List of groupId memberships required to receive the notification.',
    )
    groups: Optional[List[GroupName]] = Field(
        None,
        description='List of group memberships required to receive the notification.',
    )
    permissions: Optional[List[RestrictedPermission]] = Field(
        None, description='List of permissions required to receive the notification.'
    )


class NotificationSchemeEventDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    event: NotificationSchemeEventTypeId = Field(
        ..., description='The ID of the event.'
    )
    notifications: List[NotificationSchemeNotificationDetails] = Field(
        ...,
        description='The list of notifications mapped to a specified event.',
        max_length=255,
    )


class Operations(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    linkGroups: Optional[List[LinkGroup]] = Field(
        None, description='Details of the link groups defining issue operations.'
    )


class PageBeanComment(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[Comment]] = Field(None, description='The list of items.')


class PageBeanField(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[FieldModel]] = Field(None, description='The list of items.')


class PageBeanIssueSecurityLevelMember(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[IssueSecurityLevelMember]] = Field(
        None, description='The list of items.'
    )


class PageBeanPriority(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[Priority]] = Field(None, description='The list of items.')


class PageBeanResolutionJsonBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[ResolutionJsonBean]] = Field(
        None, description='The list of items.'
    )


class PageBeanUiModificationDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[UiModificationDetails]] = Field(
        None, description='The list of items.'
    )


class PageBeanUserDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[UserDetails]] = Field(None, description='The list of items.')


class PageBeanUserKey(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[UserKey]] = Field(None, description='The list of items.')


class PageBeanWebhook(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[Webhook]] = Field(None, description='The list of items.')


class PageOfComments(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    comments: Optional[List[Comment]] = Field(None, description='The list of comments.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )


class PageOfStatuses(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[str] = Field(
        None, description='The URL of the next page of results, if any.'
    )
    self: Optional[str] = Field(None, description='The URL of this page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned on the page.'
    )
    total: Optional[int_aliased] = Field(
        None, description='Number of items that satisfy the search.'
    )
    values: Optional[List[JiraStatus]] = Field(None, description='The list of items.')


class PageOfWorklogs(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of results that could be on the page.'
    )
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned on the page.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of results on the page.'
    )
    worklogs: Optional[List[Worklog]] = Field(None, description='List of worklogs.')


class PagedListUserDetailsApplicationUser(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    end_index: Optional[int_aliased] = Field(
        None,
        alias='end-index',
        description='The index of the last item returned on the page.',
    )
    items: Optional[List[UserDetails]] = Field(None, description='The list of items.')
    max_results: Optional[int_aliased] = Field(
        None,
        alias='max-results',
        description='The maximum number of results that could be on the page.',
    )
    size: Optional[int_aliased] = Field(
        None, description='The number of items on the page.'
    )
    start_index: Optional[int_aliased] = Field(
        None,
        alias='start-index',
        description='The index of the first item returned on the page.',
    )


class PaginatedResponseComment(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    maxResults: Optional[int_aliased] = None
    results: Optional[List[Comment]] = None
    startAt: Optional[int_aliased] = None
    total: Optional[int_aliased] = None


class PermissionGrant(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    holder: Optional[PermissionHolder] = Field(
        None,
        description='The user or group being granted the permission. It consists of a `type`, a type-dependent `parameter` and a type-dependent `value`. See [Holder object](../api-group-permission-schemes/#holder-object) in *Get all permission schemes* for more information.',
    )
    id: Optional[int_aliased] = Field(
        None, description='The ID of the permission granted details.'
    )
    permission: Optional[str] = Field(
        None,
        description='The permission to grant. This permission can be one of the built-in permissions or a custom permission added by an app. See [Built-in permissions](../api-group-permission-schemes/#built-in-permissions) in *Get all permission schemes* for more information about the built-in permissions. See the [project permission](https://developer.atlassian.com/cloud/jira/platform/modules/project-permission/) and [global permission](https://developer.atlassian.com/cloud/jira/platform/modules/global-permission/) module documentation for more information about custom permissions.',
    )
    self: Optional[AnyUrl] = Field(
        None, description='The URL of the permission granted details.'
    )


class PermissionGrants(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional permission grant details in the response.',
    )
    permissions: Optional[List[PermissionGrant]] = Field(
        None, description='Permission grants list.'
    )


class Permissions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    permissions: Optional[Dict[str, UserPermission]] = Field(
        None, description='List of permissions.'
    )


class PermittedProjects(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    projects: Optional[List[ProjectIdentifierBean]] = Field(
        None, description='A list of projects.'
    )


class ProjectDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    avatarUrls: Optional[AvatarUrlsBean] = Field(
        None, description="The URLs of the project's avatars."
    )
    id: Optional[str] = Field(None, description='The ID of the project.')
    key: Optional[str] = Field(None, description='The key of the project.')
    name: Optional[str] = Field(None, description='The name of the project.')
    projectCategory: Optional[UpdatedProjectCategory] = Field(
        None, description='The category the project belongs to.'
    )
    projectTypeKey: Optional[ProjectTypeKey] = Field(
        None,
        description='The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes) of the project.',
    )
    self: Optional[str] = Field(None, description='The URL of the project details.')
    simplified: Optional[bool] = Field(
        None, description='Whether or not the project is simplified.'
    )


class ProjectIssueSecurityLevels(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    levels: List[SecurityLevel] = Field(
        ..., description='Issue level security items list.'
    )


class ProjectIssueTypeHierarchy(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    hierarchy: Optional[List[ProjectIssueTypesHierarchyLevel]] = Field(
        None, description='Details of an issue type hierarchy level.'
    )
    projectId: Optional[int_aliased] = Field(None, description='The ID of the project.')


class PublishDraftWorkflowScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    statusMappings: Optional[List[StatusMapping]] = Field(
        None, description='Mappings of statuses to new statuses for issue types.'
    )


class RemoteObject(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    icon: Optional[Icon] = Field(
        None,
        description='Details of the icon for the item. If no icon is defined, the default link icon is used in Jira.',
    )
    status: Optional[Status] = Field(None, description='The status of the item.')
    summary: Optional[str] = Field(None, description='The summary details of the item.')
    title: str = Field(..., description='The title of the item.')
    url: str = Field(..., description='The URL of the item.')


class RemoveOptionFromIssuesResult(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    errors: Optional[SimpleErrorCollection] = Field(
        None,
        description='A collection of errors related to unchanged issues. The collection size is limited, which means not all errors may be returned.',
    )
    modifiedIssues: Optional[List[int_aliased]] = Field(
        None, description='The IDs of the modified issues.'
    )
    unmodifiedIssues: Optional[List[int_aliased]] = Field(
        None,
        description='The IDs of the unchanged issues, those issues where errors prevent modification.',
    )


class SanitizedJqlQueries(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    queries: Optional[List[SanitizedJqlQuery]] = Field(
        None, description='The list of sanitized JQL queries.'
    )


class Scope(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    project: Optional[ProjectDetails] = Field(
        None, description='The project the item has scope in.'
    )
    type: Optional[Type7] = Field(None, description='The type of scope.')


class Screen(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the screen.'
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the screen.')
    name: Optional[str] = Field(None, description='The name of the screen.')
    scope: Optional[Scope] = Field(None, description='The scope of the screen.')


class ScreenScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the screen scheme.'
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the screen scheme.')
    issueTypeScreenSchemes: Optional[PageBeanIssueTypeScreenScheme] = Field(
        None,
        description='Details of the issue type screen schemes associated with the screen scheme.',
    )
    name: Optional[str] = Field(None, description='The name of the screen scheme.')
    screens: Optional[ScreenTypes] = Field(
        None,
        description='The IDs of the screens for the screen types of the screen scheme.',
    )


class ScreenSchemeDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the screen scheme. The maximum length is 255 characters.',
    )
    name: str = Field(
        ...,
        description='The name of the screen scheme. The name must be unique. The maximum length is 255 characters.',
    )
    screens: ScreenTypes = Field(
        ...,
        description='The IDs of the screens for the screen types of the screen scheme. Only screens used in classic projects are accepted.',
    )


class ScreenWithTab(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the screen.'
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the screen.')
    name: Optional[str] = Field(None, description='The name of the screen.')
    scope: Optional[Scope] = Field(None, description='The scope of the screen.')
    tab: Optional[ScreenableTab] = Field(None, description='The tab for the screen.')


class SimpleListWrapperApplicationRole(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    callback: Optional[ListWrapperCallbackApplicationRole] = None
    items: Optional[List[ApplicationRole]] = None
    max_results: Optional[int_aliased] = Field(None, alias='max-results')
    pagingCallback: Optional[ListWrapperCallbackApplicationRole] = None
    size: Optional[int_aliased] = None


class StatusCreateRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    scope: StatusScope
    statuses: List[StatusCreate] = Field(
        ..., description='Details of the statuses being created.'
    )


class TaskProgressBeanRemoveOptionFromIssuesResult(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(None, description='The description of the task.')
    elapsedRuntime: int_aliased = Field(
        ..., description='The execution time of the task, in milliseconds.'
    )
    finished: Optional[int_aliased] = Field(
        None, description='A timestamp recording when the task was finished.'
    )
    id: str = Field(..., description='The ID of the task.')
    lastUpdate: int_aliased = Field(
        ...,
        description='A timestamp recording when the task progress was last updated.',
    )
    message: Optional[str] = Field(
        None, description='Information about the progress of the task.'
    )
    progress: int_aliased = Field(
        ..., description='The progress of the task, as a percentage complete.'
    )
    result: Optional[RemoveOptionFromIssuesResult] = Field(
        None, description='The result of the task execution.'
    )
    self: AnyUrl = Field(..., description='The URL of the task.')
    started: Optional[int_aliased] = Field(
        None, description='A timestamp recording when the task was started.'
    )
    status: Status1 = Field(..., description='The status of the task.')
    submitted: int_aliased = Field(
        ..., description='A timestamp recording when the task was submitted.'
    )
    submittedBy: int_aliased = Field(
        ..., description='The ID of the user who submitted the task.'
    )


class Transitions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional transitions details in the response.',
    )
    transitions: Optional[List[IssueTransition]] = Field(
        None, description='List of issue transitions.'
    )


class UpdateScreenSchemeDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the screen scheme. The maximum length is 255 characters.',
    )
    name: Optional[str] = Field(
        None,
        description='The name of the screen scheme. The name must be unique. The maximum length is 255 characters.',
    )
    screens: Optional[UpdateScreenTypes] = Field(
        None,
        description='The IDs of the screens for the screen types of the screen scheme. Only screens used in classic projects are accepted.',
    )


class User(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountId: Optional[constr(max_length=128)] = Field(
        None,
        description='The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*. Required in requests.',
    )
    accountType: Optional[AccountType] = Field(
        None,
        description='The user account type. Can take the following values:\n\n *  `atlassian` regular Atlassian user account\n *  `app` system account used for Connect applications and OAuth to represent external systems\n *  `customer` Jira Service Desk account representing an external service desk',
    )
    active: Optional[bool] = Field(None, description='Whether the user is active.')
    applicationRoles: Optional[SimpleListWrapperApplicationRole] = Field(
        None, description='The application roles the user is assigned to.'
    )
    avatarUrls: Optional[AvatarUrlsBean] = Field(
        None, description='The avatars of the user.'
    )
    displayName: Optional[str] = Field(
        None,
        description='The display name of the user. Depending on the users privacy setting, this may return an alternative value.',
    )
    emailAddress: Optional[str] = Field(
        None,
        description='The email address of the user. Depending on the users privacy setting, this may be returned as null.',
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional user details in the response.',
    )
    groups: Optional[SimpleListWrapperGroupName] = Field(
        None, description='The groups that the user belongs to.'
    )
    key: Optional[str] = Field(
        None,
        description='This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )
    locale: Optional[str] = Field(
        None,
        description='The locale of the user. Depending on the users privacy setting, this may be returned as null.',
    )
    name: Optional[str] = Field(
        None,
        description='This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the user.')
    timeZone: Optional[str] = Field(
        None,
        description="The time zone specified in the user's profile. Depending on the users privacy setting, this may be returned as null.",
    )


class UserBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    accountId: Optional[constr(max_length=128)] = Field(
        None,
        description='The account ID of the user, which uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.',
    )
    active: Optional[bool] = Field(None, description='Whether the user is active.')
    avatarUrls: Optional[UserBeanAvatarUrls] = Field(
        None, description='The avatars of the user.'
    )
    displayName: Optional[str] = Field(
        None,
        description='The display name of the user. Depending on the users privacy setting, this may return an alternative value.',
    )
    key: Optional[str] = Field(
        None,
        description='This property is deprecated in favor of `accountId` because of privacy changes. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.  \nThe key of the user.',
    )
    name: Optional[str] = Field(
        None,
        description='This property is deprecated in favor of `accountId` because of privacy changes. See the [migration guide](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.  \nThe username of the user.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the user.')


class UserList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    end_index: Optional[int_aliased] = Field(
        None,
        alias='end-index',
        description='The index of the last item returned on the page.',
    )
    items: Optional[List[User]] = Field(None, description='The list of items.')
    max_results: Optional[int_aliased] = Field(
        None,
        alias='max-results',
        description='The maximum number of results that could be on the page.',
    )
    size: Optional[int_aliased] = Field(
        None, description='The number of items on the page.'
    )
    start_index: Optional[int_aliased] = Field(
        None,
        alias='start-index',
        description='The index of the first item returned on the page.',
    )


class Version(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    archived: Optional[bool] = Field(
        None,
        description='Indicates that the version is archived. Optional when creating or updating a version.',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the version. Optional when creating or updating a version.',
    )
    expand: Optional[str] = Field(
        None,
        description='Use [expand](em>#expansion) to include additional information about version in the response. This parameter accepts a comma-separated list. Expand options include:\n\n *  `operations` Returns the list of operations available for this version.\n *  `issuesstatus` Returns the count of issues in this version for each of the status categories *to do*, *in progress*, *done*, and *unmapped*. The *unmapped* property contains a count of issues with a status other than *to do*, *in progress*, and *done*.\n\nOptional for create and update.',
    )
    id: Optional[str] = Field(None, description='The ID of the version.')
    issuesStatusForFixVersion: Optional[VersionIssuesStatus] = Field(
        None,
        description='If the expand option `issuesstatus` is used, returns the count of issues in this version for each of the status categories *to do*, *in progress*, *done*, and *unmapped*. The *unmapped* property contains a count of issues with a status other than *to do*, *in progress*, and *done*.',
    )
    moveUnfixedIssuesTo: Optional[AnyUrl] = Field(
        None,
        description='The URL of the self link to the version to which all unfixed issues are moved when a version is released. Not applicable when creating a version. Optional when updating a version.',
    )
    name: Optional[str] = Field(
        None,
        description='The unique name of the version. Required when creating a version. Optional when updating a version. The maximum length is 255 characters.',
    )
    operations: Optional[List[SimpleLink]] = Field(
        None,
        description='If the expand option `operations` is used, returns the list of operations available for this version.',
    )
    overdue: Optional[bool] = Field(
        None, description='Indicates that the version is overdue.'
    )
    project: Optional[str] = Field(None, description='Deprecated. Use `projectId`.')
    projectId: Optional[int_aliased] = Field(
        None,
        description='The ID of the project to which this version is attached. Required when creating a version. Not applicable when updating a version.',
    )
    releaseDate: Optional[date_aliased] = Field(
        None,
        description='The release date of the version. Expressed in ISO 8601 format (yyyy-mm-dd). Optional when creating or updating a version.',
    )
    released: Optional[bool] = Field(
        None,
        description='Indicates that the version is released. If the version is released a request to release again is ignored. Not applicable when creating a version. Optional when updating a version.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the version.')
    startDate: Optional[date_aliased] = Field(
        None,
        description='The start date of the version. Expressed in ISO 8601 format (yyyy-mm-dd). Optional when creating or updating a version.',
    )
    userReleaseDate: Optional[str] = Field(
        None,
        description="The date on which work on this version is expected to finish, expressed in the instance's *Day/Month/Year Format* date format.",
    )
    userStartDate: Optional[str] = Field(
        None,
        description="The date on which work on this version is expected to start, expressed in the instance's *Day/Month/Year Format* date format.",
    )


class VersionIssueCounts(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    customFieldUsage: Optional[List[VersionUsageInCustomField]] = Field(
        None, description='List of custom fields using the version.'
    )
    issueCountWithCustomFieldsShowingVersion: Optional[int_aliased] = Field(
        None,
        description='Count of issues where a version custom field is set to the version.',
    )
    issuesAffectedCount: Optional[int_aliased] = Field(
        None,
        description='Count of issues where the `affectedVersion` is set to the version.',
    )
    issuesFixedCount: Optional[int_aliased] = Field(
        None,
        description='Count of issues where the `fixVersion` is set to the version.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of these count details.')


class Votes(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    hasVoted: Optional[bool] = Field(
        None, description='Whether the user making this request has voted on the issue.'
    )
    self: Optional[AnyUrl] = Field(
        None, description='The URL of these issue vote details.'
    )
    voters: Optional[List[User]] = Field(
        None,
        description="List of the users who have voted on this issue. An empty list is returned when the calling user doesn't have the *View voters and watchers* project permission.",
    )
    votes: Optional[int_aliased] = Field(
        None, description='The number of votes on the issue.'
    )


class WorkflowTransitionRules(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditions: Optional[List[ConnectWorkflowTransitionRule]] = Field(
        None, description='The list of conditions within the workflow.'
    )
    postFunctions: Optional[List[ConnectWorkflowTransitionRule]] = Field(
        None, description='The list of post functions within the workflow.'
    )
    validators: Optional[List[ConnectWorkflowTransitionRule]] = Field(
        None, description='The list of validators within the workflow.'
    )
    workflowId: WorkflowId


class WorkflowTransitionRulesUpdate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    workflows: List[WorkflowTransitionRules] = Field(
        ..., description='The list of workflows with transition rules to update.'
    )


class RestApi3ApplicationroleGetResponse(RootModel[List[ApplicationRole]]):
    root: List[ApplicationRole]


class RestApi3IssueIssueIdOrKeyAttachmentsPostResponse(RootModel[List[Attachment]]):
    root: List[Attachment]


class RestApi3ProjectProjectIdOrKeyStatusesGetResponse(
    RootModel[List[IssueTypeWithStatus]]
):
    root: List[IssueTypeWithStatus]


class RestApi3ProjectProjectIdOrKeyVersionsGetResponse(RootModel[List[Version]]):
    root: List[Version]


class RestApi3StatusesGetResponse(RootModel[List[JiraStatus]]):
    root: List[JiraStatus]


class RestApi3StatusesPostResponse(RootModel[List[JiraStatus]]):
    root: List[JiraStatus]


class RestApi3UserAssignableMultiProjectSearchGetResponse(RootModel[List[User]]):
    root: List[User]


class RestApi3UserAssignableSearchGetResponse(RootModel[List[User]]):
    root: List[User]


class RestApi3UserPermissionSearchGetResponse(RootModel[List[User]]):
    root: List[User]


class RestApi3UserSearchGetResponse(RootModel[List[User]]):
    root: List[User]


class RestApi3UserViewissueSearchGetResponse(RootModel[List[User]]):
    root: List[User]


class RestApi3UsersGetResponse(RootModel[List[User]]):
    root: List[User]


class RestApi3UsersSearchGetResponse(RootModel[List[User]]):
    root: List[User]


class AddNotificationsDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    notificationSchemeEvents: List[NotificationSchemeEventDetails] = Field(
        ...,
        description='The list of notifications which should be added to the notification scheme.',
    )


class AttachmentMetadata(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    author: Optional[User] = Field(
        None, description='Details of the user who attached the file.'
    )
    content: Optional[str] = Field(None, description='The URL of the attachment.')
    created: Optional[datetime] = Field(
        None, description='The datetime the attachment was created.'
    )
    filename: Optional[str] = Field(
        None, description='The name of the attachment file.'
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the attachment.')
    mimeType: Optional[str] = Field(
        None, description='The MIME type of the attachment.'
    )
    properties: Optional[Dict[str, Any]] = Field(
        None, description='Additional properties of the attachment.'
    )
    self: Optional[AnyUrl] = Field(
        None, description='The URL of the attachment metadata details.'
    )
    size: Optional[int_aliased] = Field(None, description='The size of the attachment.')
    thumbnail: Optional[str] = Field(
        None, description='The URL of a thumbnail representing the attachment.'
    )


class Changelog(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    author: Optional[UserDetails] = Field(
        None, description='The user who made the change.'
    )
    created: Optional[datetime] = Field(
        None, description='The date on which the change took place.'
    )
    historyMetadata: Optional[HistoryMetadata] = Field(
        None, description='The history metadata associated with the changed.'
    )
    id: Optional[str] = Field(None, description='The ID of the changelog.')
    items: Optional[List[ChangeDetails]] = Field(
        None, description='The list of items changed.'
    )


class ComponentWithIssueCount(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    assignee: Optional[User] = Field(
        None,
        description='The details of the user associated with `assigneeType`, if any. See `realAssignee` for details of the user assigned to issues created with this component.',
    )
    assigneeType: Optional[AssigneeType] = Field(
        None,
        description='The nominal user type used to determine the assignee for issues created with this component. See `realAssigneeType` for details on how the type of the user, and hence the user, assigned to issues is determined. Takes the following values:\n\n *  `PROJECT_LEAD` the assignee to any issues created with this component is nominally the lead for the project the component is in.\n *  `COMPONENT_LEAD` the assignee to any issues created with this component is nominally the lead for the component.\n *  `UNASSIGNED` an assignee is not set for issues created with this component.\n *  `PROJECT_DEFAULT` the assignee to any issues created with this component is nominally the default assignee for the project that the component is in.',
    )
    description: Optional[str] = Field(
        None, description='The description for the component.'
    )
    id: Optional[str] = Field(
        None, description='The unique identifier for the component.'
    )
    isAssigneeTypeValid: Optional[bool] = Field(
        None,
        description='Whether a user is associated with `assigneeType`. For example, if the `assigneeType` is set to `COMPONENT_LEAD` but the component lead is not set, then `false` is returned.',
    )
    issueCount: Optional[int_aliased] = Field(
        None, description='Count of issues for the component.'
    )
    lead: Optional[User] = Field(
        None, description="The user details for the component's lead user."
    )
    name: Optional[str] = Field(None, description='The name for the component.')
    project: Optional[str] = Field(
        None, description='The key of the project to which the component is assigned.'
    )
    projectId: Optional[int_aliased] = Field(None, description='Not used.')
    realAssignee: Optional[User] = Field(
        None,
        description='The user assigned to issues created with this component, when `assigneeType` does not identify a valid assignee.',
    )
    realAssigneeType: Optional[RealAssigneeType] = Field(
        None,
        description='The type of the assignee that is assigned to issues created with this component, when an assignee cannot be set from the `assigneeType`. For example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead is set. This property is set to one of the following values:\n\n *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project lead has permission to be assigned issues in the project that the component is in.\n *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the component lead has permission to be assigned issues in the project that the component is in.\n *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is configured to allow unassigned issues.\n *  `PROJECT_DEFAULT` when none of the preceding cases are true.',
    )
    self: Optional[AnyUrl] = Field(
        None,
        description='The URL for this count of the issues contained in the component.',
    )


class Context(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the context.')
    name: Optional[str] = Field(None, description='The name of the context.')
    scope: Optional[Scope] = Field(None, description='The scope of the context.')


class CreateNotificationSchemeDetails(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    description: Optional[constr(max_length=4000)] = Field(
        None, description='The description of the notification scheme.'
    )
    name: constr(max_length=255) = Field(
        ...,
        description='The name of the notification scheme. Must be unique (case-insensitive).',
    )
    notificationSchemeEvents: Optional[List[NotificationSchemeEventDetails]] = Field(
        None,
        description='The list of notifications which should be added to the notification scheme.',
    )


class CreateWorkflowDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None,
        description='The description of the workflow. The maximum length is 1000 characters.',
    )
    name: str = Field(
        ...,
        description='The name of the workflow. The name must be unique. The maximum length is 255 characters. Characters can be separated by a whitespace but the name cannot start or end with a whitespace.',
    )
    statuses: List[CreateWorkflowStatusDetails] = Field(
        ...,
        description='The statuses of the workflow. Any status that does not include a transition is added to the workflow without a transition.',
    )
    transitions: List[CreateWorkflowTransitionDetails] = Field(
        ...,
        description="The transitions of the workflow. For the request to be valid, these transitions must:\n\n *  include one *initial* transition.\n *  not use the same name for a *global* and *directed* transition.\n *  have a unique name for each *global* transition.\n *  have a unique 'to' status for each *global* transition.\n *  have unique names for each transition from a status.\n *  not have a 'from' status on *initial* and *global* transitions.\n *  have a 'from' status on *directed* transitions.\n\nAll the transition statuses must be included in `statuses`.",
    )


class CreatedIssue(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(
        None, description='The ID of the created issue or subtask.'
    )
    key: Optional[str] = Field(
        None, description='The key of the created issue or subtask.'
    )
    self: Optional[str] = Field(
        None, description='The URL of the created issue or subtask.'
    )
    transition: Optional[NestedResponse] = Field(
        None,
        description='The response code and messages related to any requested transition.',
    )
    watchers: Optional[NestedResponse] = Field(
        None,
        description='The response code and messages related to any requested watchers.',
    )


class CreatedIssues(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    errors: Optional[List[BulkOperationErrorResult]] = Field(
        None, description='Error details for failed issue creation requests.'
    )
    issues: Optional[List[CreatedIssue]] = Field(
        None, description='Details of the issues created.'
    )


class CustomFieldContextDefaultValue(
    RootModel[
        Union[
            CustomFieldContextDefaultValueCascadingOption,
            CustomFieldContextDefaultValueMultipleOption,
            CustomFieldContextDefaultValueSingleOption,
            CustomFieldContextSingleUserPickerDefaults,
            CustomFieldContextDefaultValueMultiUserPicker,
            CustomFieldContextDefaultValueSingleGroupPicker,
            CustomFieldContextDefaultValueMultipleGroupPicker,
            CustomFieldContextDefaultValueDate,
            CustomFieldContextDefaultValueDateTime,
            CustomFieldContextDefaultValueURL,
            CustomFieldContextDefaultValueProject,
            CustomFieldContextDefaultValueFloat,
            CustomFieldContextDefaultValueLabels,
            CustomFieldContextDefaultValueTextField,
            CustomFieldContextDefaultValueTextArea,
            CustomFieldContextDefaultValueReadOnly,
            CustomFieldContextDefaultValueSingleVersionPicker,
            CustomFieldContextDefaultValueMultipleVersionPicker,
            CustomFieldContextDefaultValueForgeStringField,
            CustomFieldContextDefaultValueForgeMultiStringField,
            CustomFieldContextDefaultValueForgeObjectField,
            CustomFieldContextDefaultValueForgeDateTimeField,
            CustomFieldContextDefaultValueForgeGroupField,
            CustomFieldContextDefaultValueForgeMultiGroupField,
            CustomFieldContextDefaultValueForgeNumberField,
            CustomFieldContextDefaultValueForgeUserField,
            CustomFieldContextDefaultValueForgeMultiUserField,
        ]
    ]
):
    root: Union[
        CustomFieldContextDefaultValueCascadingOption,
        CustomFieldContextDefaultValueMultipleOption,
        CustomFieldContextDefaultValueSingleOption,
        CustomFieldContextSingleUserPickerDefaults,
        CustomFieldContextDefaultValueMultiUserPicker,
        CustomFieldContextDefaultValueSingleGroupPicker,
        CustomFieldContextDefaultValueMultipleGroupPicker,
        CustomFieldContextDefaultValueDate,
        CustomFieldContextDefaultValueDateTime,
        CustomFieldContextDefaultValueURL,
        CustomFieldContextDefaultValueProject,
        CustomFieldContextDefaultValueFloat,
        CustomFieldContextDefaultValueLabels,
        CustomFieldContextDefaultValueTextField,
        CustomFieldContextDefaultValueTextArea,
        CustomFieldContextDefaultValueReadOnly,
        CustomFieldContextDefaultValueSingleVersionPicker,
        CustomFieldContextDefaultValueMultipleVersionPicker,
        CustomFieldContextDefaultValueForgeStringField,
        CustomFieldContextDefaultValueForgeMultiStringField,
        CustomFieldContextDefaultValueForgeObjectField,
        CustomFieldContextDefaultValueForgeDateTimeField,
        CustomFieldContextDefaultValueForgeGroupField,
        CustomFieldContextDefaultValueForgeMultiGroupField,
        CustomFieldContextDefaultValueForgeNumberField,
        CustomFieldContextDefaultValueForgeUserField,
        CustomFieldContextDefaultValueForgeMultiUserField,
    ] = Field(..., discriminator='type')


class CustomFieldContextDefaultValueUpdate(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    defaultValues: Optional[List[CustomFieldContextDefaultValue]] = None


class DeprecatedWorkflow(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    default: Optional[bool] = None
    description: Optional[str] = Field(
        None, description='The description of the workflow.'
    )
    lastModifiedDate: Optional[str] = Field(
        None, description='The datetime the workflow was last modified.'
    )
    lastModifiedUser: Optional[str] = Field(
        None,
        description='This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )
    lastModifiedUserAccountId: Optional[str] = Field(
        None, description='The account ID of the user that last modified the workflow.'
    )
    name: Optional[str] = Field(None, description='The name of the workflow.')
    scope: Optional[Scope] = Field(
        None, description='The scope where this workflow applies'
    )
    steps: Optional[int_aliased] = Field(
        None, description='The number of steps included in the workflow.'
    )


class FieldDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    clauseNames: Optional[List[str]] = Field(
        None,
        description='The names that can be used to reference the field in an advanced search. For more information, see [Advanced searching - fields reference](https://confluence.atlassian.com/x/gwORLQ).',
    )
    custom: Optional[bool] = Field(
        None, description='Whether the field is a custom field.'
    )
    id: Optional[str] = Field(None, description='The ID of the field.')
    key: Optional[str] = Field(None, description='The key of the field.')
    name: Optional[str] = Field(None, description='The name of the field.')
    navigable: Optional[bool] = Field(
        None,
        description='Whether the field can be used as a column on the issue navigator.',
    )
    orderable: Optional[bool] = Field(
        None, description='Whether the content of the field can be used to order lists.'
    )
    schema_: Optional[JsonTypeBean] = Field(
        None, alias='schema', description='The data schema for the field.'
    )
    scope: Optional[Scope] = Field(None, description='The scope of the field.')
    searchable: Optional[bool] = Field(
        None, description='Whether the content of the field can be searched.'
    )


class FilterSubscription(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    group: Optional[GroupName] = Field(
        None, description='The group subscribing to filter.'
    )
    id: Optional[int_aliased] = Field(
        None, description='The ID of the filter subscription.'
    )
    user: Optional[User] = Field(None, description='The user subscribing to filter.')


class FilterSubscriptionsList(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    end_index: Optional[int_aliased] = Field(
        None,
        alias='end-index',
        description='The index of the last item returned on the page.',
    )
    items: Optional[List[FilterSubscription]] = Field(
        None, description='The list of items.'
    )
    max_results: Optional[int_aliased] = Field(
        None,
        alias='max-results',
        description='The maximum number of results that could be on the page.',
    )
    size: Optional[int_aliased] = Field(
        None, description='The number of items on the page.'
    )
    start_index: Optional[int_aliased] = Field(
        None,
        alias='start-index',
        description='The index of the first item returned on the page.',
    )


class Group(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional group details in the response.',
    )
    groupId: Optional[str] = Field(
        None,
        description='The ID of the group, which uniquely identifies the group across all Atlassian products. For example, *952d12c3-5b5b-4d04-bb32-44d383afc4b2*.',
    )
    name: Optional[str] = Field(None, description='The name of group.')
    self: Optional[AnyUrl] = Field(None, description='The URL for these group details.')
    users: Optional[PagedListUserDetailsApplicationUser] = Field(
        None,
        description='A paginated list of the users that are members of the group. A maximum of 50 users is returned in the list, to access additional users append `[start-index:end-index]` to the expand request. For example, to access the next 50 users, use`?expand=users[51:100]`.',
    )


class IssueFieldOptionConfiguration(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    attributes: Optional[List[Attribute]] = Field(None, description='DEPRECATED')
    scope: Optional[IssueFieldOptionScopeBean] = Field(
        None,
        description='Defines the projects that the option is available in. If the scope is not defined, then the option is available in all projects.',
    )


class IssueFieldOptionCreateBean(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    config: Optional[IssueFieldOptionConfiguration] = None
    properties: Optional[Dict[str, Any]] = Field(
        None,
        description='The properties of the option as arbitrary key-value pairs. These properties can be searched using JQL, if the extractions (see https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/) are defined in the descriptor for the issue field module.',
    )
    value: str = Field(
        ..., description="The option's name, which is displayed in Jira."
    )


class IssuePickerSuggestions(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    sections: Optional[List[IssuePickerSuggestionsIssueType]] = Field(
        None,
        description='A list of issues for an issue type suggested for use in auto-completion.',
    )


class IssueTypeDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    avatarId: Optional[int_aliased] = Field(
        None, description="The ID of the issue type's avatar."
    )
    description: Optional[str] = Field(
        None, description='The description of the issue type.'
    )
    entityId: Optional[UUID] = Field(
        None, description='Unique ID for next-gen projects.'
    )
    hierarchyLevel: Optional[int_aliased] = Field(
        None, description='Hierarchy level of the issue type.'
    )
    iconUrl: Optional[str] = Field(
        None, description="The URL of the issue type's avatar."
    )
    id: Optional[str] = Field(None, description='The ID of the issue type.')
    name: Optional[str] = Field(None, description='The name of the issue type.')
    scope: Optional[Scope] = Field(
        None,
        description='Details of the next-gen projects the issue type is available in.',
    )
    self: Optional[str] = Field(
        None, description='The URL of these issue type details.'
    )
    subtask: Optional[bool] = Field(
        None, description='Whether this issue type is used to create subtasks.'
    )


class IssueTypeIssueCreateMetadata(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    avatarId: Optional[int_aliased] = Field(
        None, description="The ID of the issue type's avatar."
    )
    description: Optional[str] = Field(
        None, description='The description of the issue type.'
    )
    entityId: Optional[UUID] = Field(
        None, description='Unique ID for next-gen projects.'
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional issue type metadata details in the response.',
    )
    fields: Optional[Dict[str, FieldMetadata]] = Field(
        None,
        description='List of the fields available when creating an issue for the issue type.',
    )
    hierarchyLevel: Optional[int_aliased] = Field(
        None, description='Hierarchy level of the issue type.'
    )
    iconUrl: Optional[str] = Field(
        None, description="The URL of the issue type's avatar."
    )
    id: Optional[str] = Field(None, description='The ID of the issue type.')
    name: Optional[str] = Field(None, description='The name of the issue type.')
    scope: Optional[Scope] = Field(
        None,
        description='Details of the next-gen projects the issue type is available in.',
    )
    self: Optional[str] = Field(
        None, description='The URL of these issue type details.'
    )
    subtask: Optional[bool] = Field(
        None, description='Whether this issue type is used to create subtasks.'
    )


class JiraExpressionEvaluationMetaDataBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    complexity: Optional[JiraExpressionsComplexityBean] = Field(
        None,
        description='Contains information about the expression complexity. For example, the number of steps it took to evaluate the expression.',
    )
    issues: Optional[IssuesMetaBean] = Field(
        None,
        description='Contains information about the `issues` variable in the context. For example, is the issues were loaded with JQL, information about the page will be included here.',
    )


class JiraExpressionResult(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    meta: Optional[JiraExpressionEvaluationMetaDataBean] = Field(
        None,
        description='Contains various characteristics of the performed expression evaluation.',
    )
    value: Any = Field(
        ...,
        description="The value of the evaluated expression. It may be a primitive JSON value or a Jira REST API object. (Some expressions do not produce any meaningful resultsfor example, an expression that returns a lambda functionif that's the case a simple string representation is returned. These string representations should not be relied upon and may change without notice.)",
    )


class JqlQueryClauseOperand(
    RootModel[Union[ListOperand, ValueOperand, FunctionOperand, KeywordOperand]]
):
    root: Union[ListOperand, ValueOperand, FunctionOperand, KeywordOperand] = Field(
        ..., description='Details of an operand in a JQL clause.'
    )


class JqlQueryClauseTimePredicate(BaseModel):
    operand: JqlQueryClauseOperand
    operator: Operator5 = Field(
        ..., description='The operator between the field and the operand.'
    )


class JqlQueryOrderByClause(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fields: List[JqlQueryOrderByClauseElement] = Field(
        ...,
        description='The list of order-by clause fields and their ordering directives.',
    )


class Notification(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    htmlBody: Optional[str] = Field(
        None, description='The HTML body of the email notification for the issue.'
    )
    restrict: Optional[NotificationRecipientsRestrictions] = Field(
        None,
        description='Restricts the notifications to users with the specified permissions.',
    )
    subject: Optional[str] = Field(
        None,
        description='The subject of the email notification for the issue. If this is not specified, then the subject is set to the issue key and summary.',
    )
    textBody: Optional[str] = Field(
        None, description='The plain text body of the email notification for the issue.'
    )
    to: Optional[NotificationRecipients] = Field(
        None, description='The recipients of the email notification for the issue.'
    )


class PageBeanChangelog(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[Changelog]] = Field(None, description='The list of items.')


class PageBeanComponentWithIssueCount(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[ComponentWithIssueCount]] = Field(
        None, description='The list of items.'
    )


class PageBeanContext(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[Context]] = Field(None, description='The list of items.')


class PageBeanCustomFieldContextDefaultValue(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[CustomFieldContextDefaultValue]] = Field(
        None, description='The list of items.'
    )


class PageBeanProjectDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[ProjectDetails]] = Field(
        None, description='The list of items.'
    )


class PageBeanScreen(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[Screen]] = Field(None, description='The list of items.')


class PageBeanScreenScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[ScreenScheme]] = Field(None, description='The list of items.')


class PageBeanScreenWithTab(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[ScreenWithTab]] = Field(
        None, description='The list of items.'
    )


class PageBeanUser(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[User]] = Field(None, description='The list of items.')


class PageBeanVersion(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[Version]] = Field(None, description='The list of items.')


class PageBeanWorkflowTransitionRules(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[WorkflowTransitionRules]] = Field(
        None, description='The list of items.'
    )


class PageOfChangelogs(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    histories: Optional[List[Changelog]] = Field(
        None, description='The list of changelogs.'
    )
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of results that could be on the page.'
    )
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned on the page.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of results on the page.'
    )


class PermissionScheme(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    description: Optional[str] = Field(
        None, description='A description for the permission scheme.'
    )
    expand: Optional[str] = Field(
        None, description='The expand options available for the permission scheme.'
    )
    id: Optional[int_aliased] = Field(
        None, description='The ID of the permission scheme.'
    )
    name: str = Field(
        ..., description='The name of the permission scheme. Must be unique.'
    )
    permissions: Optional[List[PermissionGrant]] = Field(
        None,
        description='The permission scheme to create or update. See [About permission schemes and grants](../api-group-permission-schemes/#about-permission-schemes-and-grants) for more information.',
    )
    scope: Optional[Scope] = Field(
        None, description='The scope of the permission scheme.'
    )
    self: Optional[AnyUrl] = Field(
        None, description='The URL of the permission scheme.'
    )


class PermissionSchemes(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    permissionSchemes: Optional[List[PermissionScheme]] = Field(
        None, description='Permission schemes list.'
    )


class ProjectComponent(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    assignee: Optional[User] = Field(
        None,
        description='The details of the user associated with `assigneeType`, if any. See `realAssignee` for details of the user assigned to issues created with this component.',
    )
    assigneeType: Optional[AssigneeType3] = Field(
        None,
        description='The nominal user type used to determine the assignee for issues created with this component. See `realAssigneeType` for details on how the type of the user, and hence the user, assigned to issues is determined. Can take the following values:\n\n *  `PROJECT_LEAD` the assignee to any issues created with this component is nominally the lead for the project the component is in.\n *  `COMPONENT_LEAD` the assignee to any issues created with this component is nominally the lead for the component.\n *  `UNASSIGNED` an assignee is not set for issues created with this component.\n *  `PROJECT_DEFAULT` the assignee to any issues created with this component is nominally the default assignee for the project that the component is in.\n\nDefault value: `PROJECT_DEFAULT`.  \nOptional when creating or updating a component.',
    )
    description: Optional[str] = Field(
        None,
        description='The description for the component. Optional when creating or updating a component.',
    )
    id: Optional[str] = Field(
        None, description='The unique identifier for the component.'
    )
    isAssigneeTypeValid: Optional[bool] = Field(
        None,
        description='Whether a user is associated with `assigneeType`. For example, if the `assigneeType` is set to `COMPONENT_LEAD` but the component lead is not set, then `false` is returned.',
    )
    lead: Optional[User] = Field(
        None, description="The user details for the component's lead user."
    )
    leadAccountId: Optional[constr(max_length=128)] = Field(
        None,
        description="The accountId of the component's lead user. The accountId uniquely identifies the user across all Atlassian products. For example, *5b10ac8d82e05b22cc7d4ef5*.",
    )
    leadUserName: Optional[str] = Field(
        None,
        description='This property is no longer available and will be removed from the documentation soon. See the [deprecation notice](https://developer.atlassian.com/cloud/jira/platform/deprecation-notice-user-privacy-api-migration-guide/) for details.',
    )
    name: Optional[str] = Field(
        None,
        description='The unique name for the component in the project. Required when creating a component. Optional when updating a component. The maximum length is 255 characters.',
    )
    project: Optional[str] = Field(
        None,
        description="The key of the project the component is assigned to. Required when creating a component. Can't be updated.",
    )
    projectId: Optional[int_aliased] = Field(
        None, description='The ID of the project the component is assigned to.'
    )
    realAssignee: Optional[User] = Field(
        None,
        description='The user assigned to issues created with this component, when `assigneeType` does not identify a valid assignee.',
    )
    realAssigneeType: Optional[RealAssigneeType] = Field(
        None,
        description='The type of the assignee that is assigned to issues created with this component, when an assignee cannot be set from the `assigneeType`. For example, `assigneeType` is set to `COMPONENT_LEAD` but no component lead is set. This property is set to one of the following values:\n\n *  `PROJECT_LEAD` when `assigneeType` is `PROJECT_LEAD` and the project lead has permission to be assigned issues in the project that the component is in.\n *  `COMPONENT_LEAD` when `assignee`Type is `COMPONENT_LEAD` and the component lead has permission to be assigned issues in the project that the component is in.\n *  `UNASSIGNED` when `assigneeType` is `UNASSIGNED` and Jira is configured to allow unassigned issues.\n *  `PROJECT_DEFAULT` when none of the preceding cases are true.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the component.')


class ProjectIssueCreateMetadata(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    avatarUrls: Optional[AvatarUrlsBean] = Field(
        None,
        description="List of the project's avatars, returning the avatar size and associated URL.",
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional project issue create metadata details in the response.',
    )
    id: Optional[str] = Field(None, description='The ID of the project.')
    issuetypes: Optional[List[IssueTypeIssueCreateMetadata]] = Field(
        None, description='List of the issue types supported by the project.'
    )
    key: Optional[str] = Field(None, description='The key of the project.')
    name: Optional[str] = Field(None, description='The name of the project.')
    self: Optional[str] = Field(None, description='The URL of the project.')


class ProjectRole(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    actors: Optional[List[RoleActor]] = Field(
        None, description='The list of users who act in this role.'
    )
    admin: Optional[bool] = Field(
        None, description='Whether this role is the admin role for the project.'
    )
    currentUserRole: Optional[bool] = Field(
        None, description='Whether the calling user is part of this role.'
    )
    default: Optional[bool] = Field(
        None, description='Whether this role is the default role for the project'
    )
    description: Optional[str] = Field(
        None, description='The description of the project role.'
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the project role.')
    name: Optional[str] = Field(None, description='The name of the project role.')
    roleConfigurable: Optional[bool] = Field(
        None, description='Whether the roles are configurable for this project.'
    )
    scope: Optional[Scope] = Field(
        None,
        description='The scope of the role. Indicated for roles associated with [next-gen projects](https://confluence.atlassian.com/x/loMyO).',
    )
    self: Optional[AnyUrl] = Field(
        None, description='The URL the project role details.'
    )
    translatedName: Optional[str] = Field(
        None, description='The translated name of the project role.'
    )


class ProjectRoleDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    admin: Optional[bool] = Field(
        None, description='Whether this role is the admin role for the project.'
    )
    default: Optional[bool] = Field(
        None, description='Whether this role is the default role for the project.'
    )
    description: Optional[str] = Field(
        None, description='The description of the project role.'
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the project role.')
    name: Optional[str] = Field(None, description='The name of the project role.')
    roleConfigurable: Optional[bool] = Field(
        None, description='Whether the roles are configurable for this project.'
    )
    scope: Optional[Scope] = Field(
        None,
        description='The scope of the role. Indicated for roles associated with [next-gen projects](https://confluence.atlassian.com/x/loMyO).',
    )
    self: Optional[AnyUrl] = Field(
        None, description='The URL the project role details.'
    )
    translatedName: Optional[str] = Field(
        None, description='The translated name of the project role.'
    )


class RemoteIssueLink(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    application: Optional[Application] = Field(
        None, description='Details of the remote application the linked item is in.'
    )
    globalId: Optional[str] = Field(
        None,
        description='The global ID of the link, such as the ID of the item on the remote system.',
    )
    id: Optional[int_aliased] = Field(None, description='The ID of the link.')
    object: Optional[RemoteObject] = Field(
        None, description='Details of the item linked to.'
    )
    relationship: Optional[str] = Field(
        None,
        description='Description of the relationship between the issue and the linked item.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the link.')


class RemoteIssueLinkRequest(BaseModel):
    model_config = ConfigDict(
        extra='allow',
    )
    application: Optional[Application] = Field(
        None,
        description='Details of the remote application the linked item is in. For example, trello.',
    )
    globalId: Optional[str] = Field(
        None,
        description="An identifier for the remote item in the remote system. For example, the global ID for a remote item in Confluence would consist of the app ID and page ID, like this: `appId=456&pageId=123`.\n\nSetting this field enables the remote issue link details to be updated or deleted using remote system and item details as the record identifier, rather than using the record's Jira ID.\n\nThe maximum length is 255 characters.",
    )
    object: RemoteObject = Field(..., description='Details of the item linked to.')
    relationship: Optional[str] = Field(
        None,
        description='Description of the relationship between the issue and the linked item. If not set, the relationship description "links to" is used in Jira.',
    )


class WorkflowRulesSearchDetails(BaseModel):
    invalidRules: Optional[List[UUID]] = Field(
        None,
        description='List of workflow rule IDs that do not belong to the workflow or can not be found.',
    )
    validRules: Optional[List[WorkflowTransitionRules]] = Field(
        None, description='List of valid workflow transition rules.'
    )
    workflowEntityId: Optional[UUID] = Field(
        None,
        description='The workflow ID.',
        examples=['a498d711-685d-428d-8c3e-bc03bb450ea7'],
    )


class WorkflowScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    defaultWorkflow: Optional[str] = Field(
        None,
        description='The name of the default workflow for the workflow scheme. The default workflow has *All Unassigned Issue Types* assigned to it in Jira. If `defaultWorkflow` is not specified when creating a workflow scheme, it is set to *Jira Workflow (jira)*.',
    )
    description: Optional[str] = Field(
        None, description='The description of the workflow scheme.'
    )
    draft: Optional[bool] = Field(
        None, description='Whether the workflow scheme is a draft or not.'
    )
    id: Optional[int_aliased] = Field(
        None, description='The ID of the workflow scheme.'
    )
    issueTypeMappings: Optional[Dict[str, str]] = Field(
        None,
        description='The issue type to workflow mappings, where each mapping is an issue type ID and workflow name pair. Note that an issue type can only be mapped to one workflow in a workflow scheme.',
    )
    issueTypes: Optional[Dict[str, IssueTypeDetails]] = Field(
        None, description='The issue types available in Jira.'
    )
    lastModified: Optional[str] = Field(
        None,
        description='The date-time that the draft workflow scheme was last modified. A modification is a change to the issue type-project mappings only. This property does not apply to non-draft workflows.',
    )
    lastModifiedUser: Optional[User] = Field(
        None,
        description='The user that last modified the draft workflow scheme. A modification is a change to the issue type-project mappings only. This property does not apply to non-draft workflows.',
    )
    name: Optional[str] = Field(
        None,
        description='The name of the workflow scheme. The name must be unique. The maximum length is 255 characters. Required when creating a workflow scheme.',
    )
    originalDefaultWorkflow: Optional[str] = Field(
        None,
        description='For draft workflow schemes, this property is the name of the default workflow for the original workflow scheme. The default workflow has *All Unassigned Issue Types* assigned to it in Jira.',
    )
    originalIssueTypeMappings: Optional[Dict[str, str]] = Field(
        None,
        description='For draft workflow schemes, this property is the issue type to workflow mappings for the original workflow scheme, where each mapping is an issue type ID and workflow name pair. Note that an issue type can only be mapped to one workflow in a workflow scheme.',
    )
    self: Optional[AnyUrl] = None
    updateDraftIfNeeded: Optional[bool] = Field(
        None,
        description='Whether to create or update a draft workflow scheme when updating an active workflow scheme. An active workflow scheme is a workflow scheme that is used by at least one project. The following examples show how this property works:\n\n *  Update an active workflow scheme with `updateDraftIfNeeded` set to `true`: If a draft workflow scheme exists, it is updated. Otherwise, a draft workflow scheme is created.\n *  Update an active workflow scheme with `updateDraftIfNeeded` set to `false`: An error is returned, as active workflow schemes cannot be updated.\n *  Update an inactive workflow scheme with `updateDraftIfNeeded` set to `true`: The workflow scheme is updated, as inactive workflow schemes do not require drafts to update.\n\nDefaults to `false`.',
    )


class WorkflowSchemeAssociations(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    projectIds: List[str] = Field(
        ..., description='The list of projects that use the workflow scheme.'
    )
    workflowScheme: WorkflowScheme = Field(..., description='The workflow scheme.')


class RestApi3FieldGetResponse(RootModel[List[FieldDetails]]):
    root: List[FieldDetails]


class RestApi3IssuetypeGetResponse(RootModel[List[IssueTypeDetails]]):
    root: List[IssueTypeDetails]


class RestApi3IssuetypeProjectGetResponse(RootModel[List[IssueTypeDetails]]):
    root: List[IssueTypeDetails]


class RestApi3IssuetypeIdAlternativesGetResponse(RootModel[List[IssueTypeDetails]]):
    root: List[IssueTypeDetails]


class RestApi3ProjectProjectIdOrKeyComponentsGetResponse(
    RootModel[List[ProjectComponent]]
):
    root: List[ProjectComponent]


class RestApi3ProjectProjectIdOrKeyRoledetailsGetResponse(
    RootModel[List[ProjectRoleDetails]]
):
    root: List[ProjectRoleDetails]


class RestApi3RoleGetResponse(RootModel[List[ProjectRole]]):
    root: List[ProjectRole]


class RestApi3WorkflowGetResponse(RootModel[List[DeprecatedWorkflow]]):
    root: List[DeprecatedWorkflow]


class ContainerOfWorkflowSchemeAssociations(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    values: List[WorkflowSchemeAssociations] = Field(
        ...,
        description='A list of workflow schemes together with projects they are associated with.',
    )


class EventNotification(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    emailAddress: Optional[str] = Field(None, description='The email address.')
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional event notification details in the response.',
    )
    field: Optional[FieldDetails] = Field(
        None, description='The custom user or group field.'
    )
    group: Optional[GroupName] = Field(None, description='The specified group.')
    id: Optional[int_aliased] = Field(None, description='The ID of the notification.')
    notificationType: Optional[NotificationType] = Field(
        None, description='Identifies the recipients of the notification.'
    )
    parameter: Optional[str] = Field(
        None,
        description="As a group's name can change, use of `recipient` is recommended. The identifier associated with the `notificationType` value that defines the receiver of the notification, where the receiver isn't implied by `notificationType` value. So, when `notificationType` is:\n\n *  `User` The `parameter` is the user account ID.\n *  `Group` The `parameter` is the group name.\n *  `ProjectRole` The `parameter` is the project role ID.\n *  `UserCustomField` The `parameter` is the ID of the custom field.\n *  `GroupCustomField` The `parameter` is the ID of the custom field.",
    )
    projectRole: Optional[ProjectRole] = Field(
        None, description='The specified project role.'
    )
    recipient: Optional[str] = Field(
        None,
        description="The identifier associated with the `notificationType` value that defines the receiver of the notification, where the receiver isn't implied by the `notificationType` value. So, when `notificationType` is:\n\n *  `User`, `recipient` is the user account ID.\n *  `Group`, `recipient` is the group ID.\n *  `ProjectRole`, `recipient` is the project role ID.\n *  `UserCustomField`, `recipient` is the ID of the custom field.\n *  `GroupCustomField`, `recipient` is the ID of the custom field.",
    )
    user: Optional[UserDetails] = Field(None, description='The specified user.')


class FieldChangedClause(BaseModel):
    field: JqlQueryField
    operator: Operator2 = Field(..., description='The operator applied to the field.')
    predicates: List[JqlQueryClauseTimePredicate] = Field(
        ..., description='The list of time predicates.'
    )


class FieldValueClause(BaseModel):
    field: JqlQueryField
    operand: JqlQueryClauseOperand
    operator: Operator3 = Field(
        ..., description='The operator between the field and operand.'
    )


class FieldWasClause(BaseModel):
    field: JqlQueryField
    operand: JqlQueryClauseOperand
    operator: Operator4 = Field(
        ..., description='The operator between the field and operand.'
    )
    predicates: List[JqlQueryClauseTimePredicate] = Field(
        ..., description='The list of time predicates.'
    )


class Fields(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    assignee: Optional[UserDetails] = Field(
        None, description='The assignee of the linked issue.'
    )
    issueType: Optional[IssueTypeDetails] = Field(
        None, description='The type of the linked issue.'
    )
    issuetype: Optional[IssueTypeDetails] = Field(
        None, description='The type of the linked issue.'
    )
    priority: Optional[Priority] = Field(
        None, description='The priority of the linked issue.'
    )
    status: Optional[StatusDetails] = Field(
        None, description='The status of the linked issue.'
    )
    summary: Optional[str] = Field(
        None, description='The summary description of the linked issue.'
    )
    timetracking: Optional[TimeTrackingDetails] = Field(
        None, description='The time tracking of the linked issue.'
    )


class IssueBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    changelog: Optional[PageOfChangelogs] = Field(
        None, description='Details of changelogs associated with the issue.'
    )
    editmeta: Optional[IssueUpdateMetadata] = Field(
        None,
        description='The metadata for the fields on the issue that can be amended.',
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional issue details in the response.',
    )
    fields: Optional[Dict[str, Any]] = None
    fieldsToInclude: Optional[IncludedFields] = None
    id: Optional[str] = Field(None, description='The ID of the issue.')
    key: Optional[str] = Field(None, description='The key of the issue.')
    names: Optional[Dict[str, str]] = Field(
        None, description='The ID and name of each field present on the issue.'
    )
    operations: Optional[Operations] = Field(
        None, description='The operations that can be performed on the issue.'
    )
    properties: Optional[Dict[str, Any]] = Field(
        None, description='Details of the issue properties identified in the request.'
    )
    renderedFields: Optional[Dict[str, Any]] = Field(
        None, description='The rendered value of each field present on the issue.'
    )
    schema_: Optional[Dict[str, JsonTypeBean]] = Field(
        None,
        alias='schema',
        description='The schema describing each field present on the issue.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the issue details.')
    transitions: Optional[List[IssueTransition]] = Field(
        None, description='The transitions that can be performed on the issue.'
    )
    versionedRepresentations: Optional[Dict[str, Dict[str, Any]]] = Field(
        None, description='The versions of each field on the issue.'
    )


class IssueCreateMetadata(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional project details in the response.',
    )
    projects: Optional[List[ProjectIssueCreateMetadata]] = Field(
        None, description='List of projects and their issue creation metadata.'
    )


class IssueFieldOption(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    config: Optional[IssueFieldOptionConfiguration] = None
    id: int_aliased = Field(
        ...,
        description="The unique identifier for the option. This is only unique within the select field's set of options.",
    )
    properties: Optional[Dict[str, Any]] = Field(
        None,
        description='The properties of the object, as arbitrary key-value pairs. These properties can be searched using JQL, if the extractions (see [Issue Field Option Property Index](https://developer.atlassian.com/cloud/jira/platform/modules/issue-field-option-property-index/)) are defined in the descriptor for the issue field module.',
    )
    value: str = Field(
        ..., description="The option's name, which is displayed in Jira."
    )


class LinkedIssue(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fields: Optional[Fields] = Field(
        None, description='The fields associated with the issue.'
    )
    id: Optional[str] = Field(
        None, description="The ID of an issue. Required if `key` isn't provided."
    )
    key: Optional[str] = Field(
        None, description="The key of an issue. Required if `id` isn't provided."
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the issue.')


class NotificationSchemeEvent(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    event: Optional[NotificationEvent] = None
    notifications: Optional[List[EventNotification]] = None


class PageBeanIssueFieldOption(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[IssueFieldOption]] = Field(
        None, description='The list of items.'
    )


class PageBeanWorkflowScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[WorkflowScheme]] = Field(
        None, description='The list of items.'
    )


class Project(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    archived: Optional[bool] = Field(
        None, description='Whether the project is archived.'
    )
    archivedBy: Optional[User] = Field(
        None, description='The user who archived the project.'
    )
    archivedDate: Optional[datetime] = Field(
        None, description='The date when the project was archived.'
    )
    assigneeType: Optional[AssigneeType1] = Field(
        None, description='The default assignee when creating issues for this project.'
    )
    avatarUrls: Optional[AvatarUrlsBean] = Field(
        None, description="The URLs of the project's avatars."
    )
    components: Optional[List[ProjectComponent]] = Field(
        None, description='List of the components contained in the project.'
    )
    deleted: Optional[bool] = Field(
        None, description='Whether the project is marked as deleted.'
    )
    deletedBy: Optional[User] = Field(
        None, description='The user who marked the project as deleted.'
    )
    deletedDate: Optional[datetime] = Field(
        None, description='The date when the project was marked as deleted.'
    )
    description: Optional[str] = Field(
        None, description='A brief description of the project.'
    )
    email: Optional[str] = Field(
        None, description='An email address associated with the project.'
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional project details in the response.',
    )
    favourite: Optional[bool] = Field(
        None, description='Whether the project is selected as a favorite.'
    )
    id: Optional[str] = Field(None, description='The ID of the project.')
    insight: Optional[ProjectInsight] = Field(
        None, description='Insights about the project.'
    )
    isPrivate: Optional[bool] = Field(
        None, description='Whether the project is private.'
    )
    issueTypeHierarchy: Optional[Hierarchy] = Field(
        None, description='The issue type hierarchy for the project.'
    )
    issueTypes: Optional[List[IssueTypeDetails]] = Field(
        None, description='List of the issue types available in the project.'
    )
    key: Optional[str] = Field(None, description='The key of the project.')
    landingPageInfo: Optional[ProjectLandingPageInfo] = Field(
        None, description='The project landing page info.'
    )
    lead: Optional[User] = Field(None, description='The username of the project lead.')
    name: Optional[str] = Field(None, description='The name of the project.')
    permissions: Optional[ProjectPermissions] = Field(
        None, description='User permissions on the project'
    )
    projectCategory: Optional[ProjectCategory] = Field(
        None, description='The category the project belongs to.'
    )
    projectTypeKey: Optional[ProjectTypeKey] = Field(
        None,
        description='The [project type](https://confluence.atlassian.com/x/GwiiLQ#Jiraapplicationsoverview-Productfeaturesandprojecttypes) of the project.',
    )
    properties: Optional[Dict[str, Any]] = Field(
        None, description='Map of project properties'
    )
    retentionTillDate: Optional[datetime] = Field(
        None, description='The date when the project is deleted permanently.'
    )
    roles: Optional[Dict[str, AnyUrl]] = Field(
        None,
        description='The name and self URL for each role defined in the project. For more information, see [Create project role](#api-rest-api-3-role-post).',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the project details.')
    simplified: Optional[bool] = Field(
        None, description='Whether the project is simplified.'
    )
    style: Optional[Style] = Field(None, description='The type of the project.')
    url: Optional[str] = Field(
        None,
        description='A link to information about this project, such as project documentation.',
    )
    uuid: Optional[UUID] = Field(None, description='Unique ID for next-gen projects.')
    versions: Optional[List[Version]] = Field(
        None,
        description='The versions defined in the project. For more information, see [Create version](#api-rest-api-3-version-post).',
    )


class SearchResults(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional search result details in the response.',
    )
    issues: Optional[List[IssueBean]] = Field(
        None, description='The list of issues found by the search.'
    )
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of results that could be on the page.'
    )
    names: Optional[Dict[str, str]] = Field(
        None, description='The ID and name of each field in the search results.'
    )
    schema_: Optional[Dict[str, JsonTypeBean]] = Field(
        None,
        alias='schema',
        description='The schema describing the field types in the search results.',
    )
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned on the page.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of results on the page.'
    )
    warningMessages: Optional[List[str]] = Field(
        None, description='Any warnings related to the JQL query.'
    )


class SharePermission(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    group: Optional[GroupName] = Field(
        None,
        description="The group that the filter is shared with. For a request, specify the `groupId` or `name` property for the group. As a group's name can change, use of `groupId` is recommended.",
    )
    id: Optional[int_aliased] = Field(
        None, description='The unique identifier of the share permission.'
    )
    project: Optional[Project] = Field(
        None,
        description='The project that the filter is shared with. This is similar to the project object returned by [Get project](#api-rest-api-3-project-projectIdOrKey-get) but it contains a subset of the properties, which are: `self`, `id`, `key`, `assigneeType`, `name`, `roles`, `avatarUrls`, `projectType`, `simplified`.  \nFor a request, specify the `id` for the project.',
    )
    role: Optional[ProjectRole] = Field(
        None,
        description='The project role that the filter is shared with.  \nFor a request, specify the `id` for the role. You must also specify the `project` object and `id` for the project that the role is in.',
    )
    type: Type8 = Field(
        ...,
        description='The type of share permission:\n\n *  `user` Shared with a user.\n *  `group` Shared with a group. If set in a request, then specify `sharePermission.group` as well.\n *  `project` Shared with a project. If set in a request, then specify `sharePermission.project` as well.\n *  `projectRole` Share with a project role in a project. This value is not returned in responses. It is used in requests, where it needs to be specify with `projectId` and `projectRoleId`.\n *  `global` Shared globally. If set in a request, no other `sharePermission` properties need to be specified.\n *  `loggedin` Shared with all logged-in users. Note: This value is set in a request by specifying `authenticated` as the `type`.\n *  `project-unknown` Shared with a project that the user does not have access to. Cannot be set in a request.',
    )
    user: Optional[UserBean] = Field(
        None,
        description='The user account ID that the filter is shared with. For a request, specify the `accountId` property for the user.',
    )


class RestApi3FilterIdPermissionGetResponse(RootModel[List[SharePermission]]):
    root: List[SharePermission]


class RestApi3FilterIdPermissionPostResponse(RootModel[List[SharePermission]]):
    root: List[SharePermission]


class RestApi3ProjectGetResponse(RootModel[List[Project]]):
    root: List[Project]


class RestApi3ProjectRecentGetResponse(RootModel[List[Project]]):
    root: List[Project]


class Dashboard(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    automaticRefreshMs: Optional[int_aliased] = Field(
        None,
        description='The automatic refresh interval for the dashboard in milliseconds.',
    )
    description: Optional[str] = None
    editPermissions: Optional[List[SharePermission]] = Field(
        None, description='The details of any edit share permissions for the dashboard.'
    )
    id: Optional[str] = Field(None, description='The ID of the dashboard.')
    isFavourite: Optional[bool] = Field(
        None, description='Whether the dashboard is selected as a favorite by the user.'
    )
    isWritable: Optional[bool] = Field(
        None,
        description='Whether the current user has permission to edit the dashboard.',
    )
    name: Optional[str] = Field(None, description='The name of the dashboard.')
    owner: Optional[UserBean] = Field(None, description='The owner of the dashboard.')
    popularity: Optional[int_aliased] = Field(
        None, description='The number of users who have this dashboard as a favorite.'
    )
    rank: Optional[int_aliased] = Field(None, description='The rank of this dashboard.')
    self: Optional[AnyUrl] = Field(
        None, description='The URL of these dashboard details.'
    )
    sharePermissions: Optional[List[SharePermission]] = Field(
        None, description='The details of any view share permissions for the dashboard.'
    )
    systemDashboard: Optional[bool] = Field(
        None, description='Whether the current dashboard is system dashboard.'
    )
    view: Optional[str] = Field(None, description='The URL of the dashboard.')


class DashboardDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the dashboard.'
    )
    editPermissions: List[SharePermission] = Field(
        ..., description='The edit permissions for the dashboard.'
    )
    name: str = Field(..., description='The name of the dashboard.')
    sharePermissions: List[SharePermission] = Field(
        ..., description='The share permissions for the dashboard.'
    )


class Filter(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(None, description='A description of the filter.')
    editPermissions: Optional[List[SharePermission]] = Field(
        None, description='The groups and projects that can edit the filter.'
    )
    favourite: Optional[bool] = Field(
        None, description='Whether the filter is selected as a favorite.'
    )
    favouritedCount: Optional[int_aliased] = Field(
        None,
        description='The count of how many users have selected this filter as a favorite, including the filter owner.',
    )
    id: Optional[str] = Field(None, description='The unique identifier for the filter.')
    jql: Optional[str] = Field(
        None,
        description='The JQL query for the filter. For example, *project = SSP AND issuetype = Bug*.',
    )
    name: str = Field(..., description='The name of the filter. Must be unique.')
    owner: Optional[User] = Field(
        None,
        description='The user who owns the filter. This is defaulted to the creator of the filter, however Jira administrators can change the owner of a shared filter in the admin settings.',
    )
    searchUrl: Optional[AnyUrl] = Field(
        None,
        description="A URL to view the filter results in Jira, using the [Search for issues using JQL](#api-rest-api-3-filter-search-get) operation with the filter's JQL string to return the filter results. For example, *https://your-domain.atlassian.net/rest/api/3/search?jql=project+%3D+SSP+AND+issuetype+%3D+Bug*.",
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the filter.')
    sharePermissions: Optional[List[SharePermission]] = Field(
        None, description='The groups and projects that the filter is shared with.'
    )
    sharedUsers: Optional[UserList] = Field(
        None,
        description='A paginated list of the users that the filter is shared with. This includes users that are members of the groups or can browse the projects that the filter is shared with.',
    )
    subscriptions: Optional[FilterSubscriptionsList] = Field(
        None,
        description='A paginated list of the users that are subscribed to the filter.',
    )
    viewUrl: Optional[AnyUrl] = Field(
        None,
        description='A URL to view the filter results in Jira, using the ID of the filter. For example, *https://your-domain.atlassian.net/issues/?filter=10100*.',
    )


class FilterDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the filter.'
    )
    editPermissions: Optional[List[SharePermission]] = Field(
        None,
        description='The groups and projects that can edit the filter. This can be specified when updating a filter, but not when creating a filter.',
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional filter details in the response.',
    )
    favourite: Optional[bool] = Field(
        None,
        description='Whether the filter is selected as a favorite by any users, not including the filter owner.',
    )
    favouritedCount: Optional[int_aliased] = Field(
        None,
        description='The count of how many users have selected this filter as a favorite, including the filter owner.',
    )
    id: Optional[str] = Field(None, description='The unique identifier for the filter.')
    jql: Optional[str] = Field(
        None,
        description='The JQL query for the filter. For example, *project = SSP AND issuetype = Bug*.',
    )
    name: str = Field(..., description='The name of the filter.')
    owner: Optional[User] = Field(
        None,
        description='The user who owns the filter. Defaults to the creator of the filter, however, Jira administrators can change the owner of a shared filter in the admin settings.',
    )
    searchUrl: Optional[AnyUrl] = Field(
        None,
        description="A URL to view the filter results in Jira, using the [Search for issues using JQL](#api-rest-api-3-filter-search-get) operation with the filter's JQL string to return the filter results. For example, *https://your-domain.atlassian.net/rest/api/3/search?jql=project+%3D+SSP+AND+issuetype+%3D+Bug*.",
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the filter.')
    sharePermissions: Optional[List[SharePermission]] = Field(
        None,
        description='The groups and projects that the filter is shared with. This can be specified when updating a filter, but not when creating a filter.',
    )
    subscriptions: Optional[List[FilterSubscription]] = Field(
        None, description='The users that are subscribed to the filter.'
    )
    viewUrl: Optional[AnyUrl] = Field(
        None,
        description='A URL to view the filter results in Jira, using the ID of the filter. For example, *https://your-domain.atlassian.net/issues/?filter=10100*.',
    )


class IssueLink(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Optional[str] = Field(None, description='The ID of the issue link.')
    inwardIssue: LinkedIssue = Field(
        ...,
        description='Provides details about the linked issue. If presenting this link in a user interface, use the `inward` field of the issue link type to label the link.',
    )
    outwardIssue: LinkedIssue = Field(
        ...,
        description='Provides details about the linked issue. If presenting this link in a user interface, use the `outward` field of the issue link type to label the link.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the issue link.')
    type: IssueLinkType = Field(..., description='The type of link between the issues.')


class LinkIssueRequestJsonBean(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    comment: Optional[Comment] = None
    inwardIssue: LinkedIssue
    outwardIssue: LinkedIssue
    type: IssueLinkType


class NotificationScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = Field(
        None, description='The description of the notification scheme.'
    )
    expand: Optional[str] = Field(
        None,
        description='Expand options that include additional notification scheme details in the response.',
    )
    id: Optional[int_aliased] = Field(
        None, description='The ID of the notification scheme.'
    )
    name: Optional[str] = Field(
        None, description='The name of the notification scheme.'
    )
    notificationSchemeEvents: Optional[List[NotificationSchemeEvent]] = Field(
        None, description='The notification events and associated recipients.'
    )
    projects: Optional[List[int_aliased]] = Field(
        None,
        description='The list of project IDs associated with the notification scheme.',
    )
    scope: Optional[Scope] = Field(
        None, description='The scope of the notification scheme.'
    )
    self: Optional[str] = None


class PageBeanDashboard(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[Dashboard]] = Field(None, description='The list of items.')


class PageBeanFilterDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[FilterDetails]] = Field(
        None, description='The list of items.'
    )


class PageBeanNotificationScheme(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[NotificationScheme]] = Field(
        None, description='The list of items.'
    )


class PageBeanProject(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[Project]] = Field(None, description='The list of items.')


class PageOfDashboards(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    dashboards: Optional[List[Dashboard]] = Field(
        None, description='List of dashboards.'
    )
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of results that could be on the page.'
    )
    next: Optional[str] = Field(
        None, description='The URL of the next page of results, if any.'
    )
    prev: Optional[str] = Field(
        None, description='The URL of the previous page of results, if any.'
    )
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned on the page.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of results on the page.'
    )


class RestApi3FilterGetResponse(RootModel[List[Filter]]):
    root: List[Filter]


class RestApi3FilterFavouriteGetResponse(RootModel[List[Filter]]):
    root: List[Filter]


class RestApi3FilterMyGetResponse(RootModel[List[Filter]]):
    root: List[Filter]


class CompoundClause(BaseModel):
    clauses: List[JqlQueryClause] = Field(
        ..., description='The list of nested clauses.'
    )
    operator: Operator = Field(..., description='The operator between the clauses.')


class JqlQuery(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    orderBy: Optional[JqlQueryOrderByClause] = None
    where: Optional[JqlQueryClause] = None


class JqlQueryClause(
    RootModel[
        Union[CompoundClause, FieldValueClause, FieldWasClause, FieldChangedClause]
    ]
):
    root: Union[
        CompoundClause, FieldValueClause, FieldWasClause, FieldChangedClause
    ] = Field(..., description='A JQL query clause.')


class PageBeanWorkflow(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    isLast: Optional[bool] = Field(None, description='Whether this is the last page.')
    maxResults: Optional[int_aliased] = Field(
        None, description='The maximum number of items that could be returned.'
    )
    nextPage: Optional[AnyUrl] = Field(
        None,
        description='If there is another page of results, the URL of the next page.',
    )
    self: Optional[AnyUrl] = Field(None, description='The URL of the page.')
    startAt: Optional[int_aliased] = Field(
        None, description='The index of the first item returned.'
    )
    total: Optional[int_aliased] = Field(
        None, description='The number of items returned.'
    )
    values: Optional[List[Workflow]] = Field(None, description='The list of items.')


class ParsedJqlQueries(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    queries: List[ParsedJqlQuery] = Field(
        ..., description='A list of parsed JQL queries.', min_length=1
    )


class ParsedJqlQuery(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    errors: Optional[List[str]] = Field(
        None, description='The list of syntax or validation errors.'
    )
    query: str = Field(..., description='The JQL query that was parsed and validated.')
    structure: Optional[JqlQuery] = Field(
        None,
        description='The syntax tree of the query. Empty if the query was invalid.',
    )


class Transition(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: str = Field(..., description='The description of the transition.')
    from_: List[str] = Field(
        ..., alias='from', description='The statuses the transition can start from.'
    )
    id: str = Field(..., description='The ID of the transition.')
    name: str = Field(..., description='The name of the transition.')
    properties: Optional[Dict[str, Any]] = Field(
        None, description='The properties of the transition.'
    )
    rules: Optional[WorkflowRules] = None
    screen: Optional[TransitionScreenDetails] = None
    to: str = Field(..., description='The status the transition goes to.')
    type: Type11 = Field(..., description='The type of the transition.')


class Workflow(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    created: Optional[datetime] = Field(
        None, description='The creation date of the workflow.'
    )
    description: str = Field(..., description='The description of the workflow.')
    hasDraftWorkflow: Optional[bool] = Field(
        None, description='Whether the workflow has a draft version.'
    )
    id: PublishedWorkflowId
    isDefault: Optional[bool] = Field(
        None, description='Whether this is the default workflow.'
    )
    operations: Optional[WorkflowOperations] = None
    projects: Optional[List[ProjectDetails]] = Field(
        None,
        description='The projects the workflow is assigned to, through workflow schemes.',
    )
    schemes: Optional[List[WorkflowSchemeIdName]] = Field(
        None, description='The workflow schemes the workflow is assigned to.'
    )
    statuses: Optional[List[WorkflowStatus]] = Field(
        None, description='The statuses of the workflow.'
    )
    transitions: Optional[List[Transition]] = Field(
        None, description='The transitions of the workflow.'
    )
    updated: Optional[datetime] = Field(
        None, description='The last edited date of the workflow.'
    )


class WorkflowCompoundCondition(BaseModel):
    conditions: List[WorkflowCondition] = Field(
        ..., description='The list of workflow conditions.'
    )
    nodeType: Literal['compound']
    operator: Operator6 = Field(..., description='The compound condition operator.')


class WorkflowCondition(
    RootModel[Union[WorkflowSimpleCondition, WorkflowCompoundCondition]]
):
    root: Union[WorkflowSimpleCondition, WorkflowCompoundCondition] = Field(
        ...,
        description='The workflow transition rule conditions tree.',
        discriminator='nodeType',
    )


class WorkflowRules(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    conditionsTree: Optional[WorkflowCondition] = None
    postFunctions: Optional[List[WorkflowTransitionRule]] = Field(
        None, description='The workflow post functions.'
    )
    validators: Optional[List[WorkflowTransitionRule]] = Field(
        None, description='The workflow validators.'
    )


CreateWorkflowCondition.model_rebuild()
NotificationEvent.model_rebuild()
LinkGroup.model_rebuild()
CompoundClause.model_rebuild()
JqlQuery.model_rebuild()
PageBeanWorkflow.model_rebuild()
ParsedJqlQueries.model_rebuild()
Transition.model_rebuild()
WorkflowCompoundCondition.model_rebuild()
